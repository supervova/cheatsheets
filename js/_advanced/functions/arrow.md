Синтаксис функции через «стрелку» `=>`, без ключевого слова `function` и в простых, однострочных случаях без ключевого слова  `return`.

Компактность функций-стрелок значительно облегчает чтение кода. Но главная особенность стрелочных функций в другом. **У них нет своего `this`.** Если происходит обращение к `this`, его значение берётся снаружи, из внешней функции.

Функции-стрелки предназначены для небольшого кода (например, обратного вызова), который не имеет своего контекста, выполняясь в родительском.

В примере внутри `forEach` использована стрелочная функция. И это значит, что `this.title` в ней будет иметь точно такое же значение, как в методе `showList` — `group.title`.

```javascript
const group = {
  title: 'Наш курс',
  students: ['Вася', 'Петя', 'Даша'],

  showList() {
    this.students.forEach(
      // стрелочная функция, в которой this тот
      // же, что и у родительского метода
      student => alert(`${this.title}: student`),
    );
  },
};
```

⚠️ **Стрелочные функции не надо писать везде.** Главным образом — там, где нужно сохранить контекст родителя: обработчиках событий, ajax-запросах, анимации (`setInterval`, `setTimeout`). То есть, **когда функция передается, как аргумент в другую функцию или встроенный метод**.

⛔️ Стрелочные функции не могут быть использованы как конструкторы, с `new` — потому что у них нет `this`. У функций-стрелок нет свойства `prototype`.

#### Простейший вариант стрелочной функции

Слева от `=>` находится параметр (`x` в данном случае), а справа – выражение, которое нужно вернуть. Без слова `return` — в кратком синтаксисе стрелочных функций результат возвращается без лишних формальностей.

```javascript
const myFunc = x => x + 1;

// Сейчас функция myFunc вернет 2
alert(myFunc(1));

// Та же функция в традиционном синтаксисе:
const myFunc2 = function (x) { return x + 1; };
```

Если аргументов несколько, то нужно обернуть их в скобки ()

```javascript
const sum = (a, b) => a + b;

// Функция sum вернет 3
alert(sum(1, 2));
```

Если нужно задать функцию без аргументов, используются пустые скобки.

В примере вызов `getTime()` будет возвращать текущий час.

```javascript
const getTime = () => `${new Date().getHours()}:`;
alert(getTime());
```

Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки.

```javascript
const getTime = () => {
  const date = new Date();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  return `${hours}: ${minutes}`;
};
```

☝️🧐 Заметим, что как только тело функции оборачивается в {...}, то её результат уже не возвращается автоматически, как в кратком синтаксисе. Такой функции нужен явный `return`, если, конечно, нужно что-либо возвратить.

```javascript
const myFunc3 = x => x * x;

const myFunc4 = (x, y) => {
  const newSum = x + y;

  // Здесь нужно явно вернуть результат
  return newSum;
};
```

**Примеры** использования стрелочных функций для обратного вызова.

```javascript
const myArr = [5, 8, 3];

/* В методе Array.sort используем стрелочную
функцию обратного вызова. Такая запись –
коротка и понятна… */
const sorted = myArr.sort((a, b) => a - b);
alert(sorted); // 3, 5, 8

/* В gulpfil'e функции-стрелки также используются
для обратного вызова */
gulp.task('twig', () =>
  gulp.src('/src/*.twig')
    .pipe(gulp.dest('/dist')),
);
```

#### У функций-стрелок нет переменной `arguments`

В JavaScript функции в традиционном синтаксисе может быть вызвана с произвольным количеством аргументов. Переданные аргументы сохраняются после вызова функции в псевдомассив `arguments` и становятся доступны по номерам: `arguments[0]`, `arguments[1]`…

Но они могут использовать псевдомассив аргументов внешней традиционной функции.

```javascript
function myFunc5(...args) {
  const showArg = () => alert(args[0]);

  /* Вызов showArg() вернет «Ты это видел?»,
  получив его из аргументов myFunc5 */
  showArg();
}

myFunc5('Ты это видел?');
```
