Синтаксис функции через «стрелку» `=>`, без ключевого слова `function` и в простых, однострочных случаях без ключевого слова  `return`.

Компактность функций-стрелок значительно облегчает чтение кода. Но главная особенность стрелочных функций в другом. **У них нет своего `this`.** Если происходит обращение к `this`, его значение берётся снаружи, из внешней функции.

Функции-стрелки предназначены для небольшого кода (например, обратного вызова), который не имеет своего контекста, выполняясь в родительском.

В примере внутри `forEach` использована стрелочная функция. И это значит, что `this.title` в ней будет иметь точно такое же значение, как в методе `showList` — `group.title`.

```js
const group = {
  title: 'Наш курс',
  students: ['Вася', 'Петя', 'Даша'],

  showList() {
    this.students.forEach(
      // стрелочная функция, в которой this тот
      // же, что и у родительского метода
      student => alert(`${this.title}: student`),
    );
  },
};
```

⚠️ **Стрелочные функции не надо писать везде.** Главным образом — там, где нужно сохранить контекст родителя: обработчиках событий, ajax-запросах, анимации (`setInterval`, `setTimeout`). То есть, **когда функция передается, как аргумент в другую функцию или встроенный метод**.

⛔️ Стрелочные функции не могут быть использованы как конструкторы, с `new` — потому что у них нет `this`. У функций-стрелок нет свойства `prototype`.

#### Простейший вариант стрелочной функции

Слева от `=>` находится параметр (`x` в данном случае), а справа – выражение, которое нужно вернуть. Без слова `return` — в кратком синтаксисе стрелочных функций результат возвращается без лишних формальностей.

```js
const myFunc = x => x + 1;

// Сейчас функция myFunc вернет 2
alert(myFunc(1));

// Та же функция в традиционном синтаксисе:
const myFunc2 = function (x) { return x + 1; };
```

Если аргументов несколько, то нужно обернуть их в скобки ()

```js
const sum = (a, b) => a + b;

// Функция sum вернет 3
alert(sum(1, 2));
```

Если нужно задать функцию без аргументов, используются пустые скобки.

В примере вызов `getTime()` будет возвращать текущий час.

```js
const getTime = () => `${new Date().getHours()}:`;
alert(getTime());
```

Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки.

```js
const getTime = () => {
  const date = new Date();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  return `${hours}: ${minutes}`;
};
```

☝️🧐 Заметим, что как только тело функции оборачивается в {...}, то её результат уже не возвращается автоматически, как в кратком синтаксисе. Такой функции нужен явный `return`, если, конечно, нужно что-либо возвратить.

```js
const myFunc3 = x => x * x;

const myFunc4 = (x, y) => {
  const newSum = x + y;

  // Здесь нужно явно вернуть результат
  return newSum;
};
```

**Примеры** использования стрелочных функций для обратного вызова.

```js
const myArr = [5, 8, 3];

/* В методе Array.sort используем стрелочную
функцию обратного вызова. Такая запись –
коротка и понятна… */
const sorted = myArr.sort((a, b) => a - b);
alert(sorted); // 3, 5, 8

/* В gulpfil'e функции-стрелки также используются
для обратного вызова */
gulp.task('twig', () =>
  gulp.src('/src/*.twig')
    .pipe(gulp.dest('/dist')),
);
```

#### Когда стрелочные функции использовать нельзя

**Во-первых**, их бесполезно использовать, как методы объектов.

```js
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```

Если вызвать `cat.jumps` из примера, количество жизней не уменьшается. Это происходит потому, что `this` в стрелочной функции не привязывается к внешнему объекту.

**Во-вторых**. Если нам нужен динамический контекст — в частности, в обратном вызове стрелочная функция вернет TypeError. Это связано с тем, что `this` не привязана к источнику события.

```js
const button = document.getElementById('press');
button.addEventListener('click', () => {
  // `this` здесь будет возвращать ошибку
  this.classList.toggle('on');
});
```

Решение — использовать вместо `this` объект `event` и его свойства `currentTarget` (объект на который установлен слушатель) или `target` (инициатор события, может быть потомком целевого объекта — например, `span`'ом в кнопке).

```js
button.addEventListener('click', (e) => {
  e.currentTarget.classList.toggle('on');
});
```

#### Когда точно стоит использовать стрелочные функции

Стрелочные функции отлично подойдут для случаев, когда вам не нужен собственный контекст функции.

Также мне очень нравится использовать стрелочные функции во всяких `forEach` (с использованием e.currentTarget), `map` и `reduce` — код так лучше читается.

#### Кстати, у функций-стрелок нет переменной `arguments`

Но они могут использовать псевдомассив аргументов внешней, традиционной функции.

```js
function myFunc5(...args) {
  const showArg = () => alert(args[0]);

  /* Вызов showArg() вернет «Ты это видел?»,
  получив его из аргументов myFunc5 */
  showArg();
}

myFunc5('Ты это видел?');
```
