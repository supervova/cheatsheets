В теле функции могут быть вызваны другие функции для выполнения подзадач. Но также функция может вызвать сама себя. Это называется рекурсией.

Любая рекурсивная функция может быть заменена циклом.

#### Пример №1

```javascript
function countSheep(number) {
  if (number === 0) {
    console.log('Zzzzzz');
  // Пока количество овец не равно 0…
  } else {
    // …Комментировать прыжок очередной овцы.
    console.log('A sheep jumps over the fence.');
    // Рекурсивный вызов функции. Аргумент number
    // уменьшается на единицу
    countSheep(number - 1);
  }
}

countSheep(24);
```

Хотя в большинстве случаев цикл проще, понятнее рекурсии и не создает проблем со стеком (выделенным ресурсом оперативной памяти), используют то, что более удобно. Если реализация очевидна в терминах цикла, не следует использовать рекурсию. И наоборот.

Так, в цикле разумнее решать задачи, где результат следующего полностью зависит от результата предыдущего.

**При таких задачах, как обход вложенных каталогов**, когда у каждого имеется ряд своих отдельных переменных (например, количество файлов в данном каталоге), **легче поддерживать рекурсию**. Потому что обход одного каталога совсем не зависит от результатов обхода другого соседнего каталога, и они могут **работать параллельно**, независимо друг от друга. А затем в конце просто объединяют все свои результаты.

**Скорость вычислений и потребление ресурсов.** На малых числах циклы и рекурсии почти не отличаются. На больших — рекурсия быстрее, но при этом использует больше оперативной памяти и ресурсов ЦП (центрального процессора; CPU).

Промежуточные результаты вычисления рекурсивных функций часто сохраняются не в переменных, а в стеке (см. термины)

#### Пример №2. возведение в степень

```javascript
function pow(x, n) {
  // Пока n не равно 1…
  if (n !== 1) {
    /* …Функция вызывает сама себя, возвращает
    промежуточные результаты, всякий раз
    уменьшая аргумент степени на единицу
    return 2 * pow(2, 2)
    return 2 * pow(2, 1) */
    return x * pow(x, n - 1);
  }
  return x;
}

// 2^3 = 8
alert(pow(2, 3));
```

#### Пример №3

```javascript
const n = 3;

function howManyDollars(amountOfMoney) {
  if (n < 0) {
    /* Как правило, рекурсивная функция требует
    условия прекращения — во избежание
    бесконечных циклов */
    return console.log(
      'The negative numbers are not allowed'
    );
  }

  /* Т.н. базовый случай. Обычно — в конструкции
  if(). Условие окончания вычислений, выхода
  из функции, возвращение перехода к дальнейшим
  инструкциям в порядке исполнения. */
  if (amountOfMoney < 1) {
    return 0;
  }


  /* Теперь функция вызывает сама себя —
  рекурсивный случай. И будет вызывать до тех
  пор, пока не достигнет условия базового
  случая — в рекурсивном случае должны быть
  заложены соответствующие вычисления. В данном
  примере (расчет сдачи при оплате покупки),
  если в сдаче меньше доллара, функция
  возвращает ноль — долларов покупателю
  не вернут. Если amountOfMoney больше доллара,
  функция откладывает 1 доллар «в сторону»,
  вычитает его из суммы сдачи. И снова
  запускает себя — до тех пор, пока не вычтет
  из суммы сдачи все целые доллары. */
  return
    1 + this.howManyDollars(amountOfMoney - 1.00);
}
```

#### Пример №4 — факториал

```javascript
const factorial = (n) => {
  if (n <= 1) {
    return 1;
  }

  /* Рекурсивный вызов с механизмом достижения
  базового случая - уменьшением аргумента */
  return n * factorial(n - 1);
};

/* В этом примере функция вызвана с аргументом 3.
Факториал числа n — произведение всех
натуральных чисел от 1 до n включительно. То
есть, нам нужно перемножить 3 * 2 * 1
и получить 6.

1) Первая итерация. 3 больше 1, значит
выполняется рекурсивный вызов. Умножаем
аргумент на факториал числа, меньшего на
единицу.
n = 3
n - 1 = 2
3 * factorial(2)
Но факториал двух нам тоже не известен.

2) Рекурсивный вызов — factorial(2).
2 * factorial(1)
Факториал единицы пока также не известен,
поэтому процедура повторяется.

3) Достигнут базовый случай n <= 1
Мы получили первый ответ, который используем
поднимаясь по стеку, по логической лестнице
вверх.

4) Компьютер вычисляет факториал двух 2.
2 * 1 = 2

5) Затем, когда получено значение факториала
двух, компьютер возвращается к расчету
исходного задания — факториалу трех:
3 * 2 = 6 */

factorial(3);
```

#### Пример №5

```javascript
let change = 0;

/* Рекурсивные функции могут иметь сколько угодно
параметров… */
function howManyCoins(
  coinName, coinAmount, coinsSoFar
) {
  if (change < coinAmount) {
    console.log(`${coinsSoFar} ${coinName}`);
  } else {
    change -= coinAmount;
  }

  /* …Но в рекурсивном случае меняется, как
  правило, один или два. При этом
  задействованные параметры должны меняться
  так, чтобы приближать исполнение условия
  базового случая. В данном примере
  увеличивается количество монет определенного
  номинала в сдаче — до тех пор, пока сдача
  больше суммы монеток этого номинала */
  return howManyCoins(
    coinName, coinAmount, coinsSoFar + 1
  );
}

howManyCoins('dollar bills', 1.00, 0);
howManyCoins('quarters', 0.25, 0);
howManyCoins('dimes', 0.10, 0);

```
