Один из важнейших принципов объектно-ориентированного программирования – разделение свойств и методов разделены на 2 группы.

#### Внутренний и внешний интерфейсы

В JavaScript есть два типа полей (свойств и методов) объекта:

- **Приватные**: доступны только внутри класса. Они относятся к **внутреннему интерфейсу**. В материальном мире им аналогична сложная начинка бытовых приборов, скрытая под защитным кожухом.
- **Публичные**: доступны отовсюду. Они составляют **внешний интерфейс**. В материальном мире им соответствуют кнопки включения и бегунки регулировки.

Во многих других языках также существуют **защищённые** поля. Они доступны внутри класса, как приватные. Но кроме того, доступны и в наследуемых классах.

Защищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют.

Сделаем виртуальную кофеварку на JavaScript со всеми этими типами свойств.

#### Защищённое свойство "waterAmount"

Давайте для начала создадим простой класс для описания кофеварки:

```javascript
class CoffeeMachine {
  static waterAmount = 0; // количество воды внутри

  constructor(power) {
    this.power = power;
    alert(`Создана кофеварка, мощность: ${power}`);
  }
}

// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

// добавляем воды
coffeeMachine.waterAmount = 200;
```

Прямо сейчас свойства `waterAmount` и `power` публичные. Мы можем легко получать и устанавливать им любое значение извне.

Давайте изменим свойство `waterAmount` на защищённое, чтобы иметь больше контроля над ним. Например, мы не хотим, чтобы кто-либо устанавливал его ниже нуля.

**Названия защищённых свойств обычно начинаются с префикса `_`.** Это не синтаксис языка — просто общепринятое соглашение.

Так что наше свойство будет называться `_waterAmount`:

```javascript
class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error(
      "Отрицательное количество воды"
    );
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }
}

// создаём новую кофеварку
let coffeeMachine = new CoffeeMachine(100);

/* устанавливаем количество воды и получаем
Error: Отрицательное количество воды */
coffeeMachine.waterAmount = -10;
```

Теперь доступ под контролем, поэтому указать воду ниже нуля не удалось.

## Свойство только для чтения «power»

Давайте сделаем свойство `power` доступным только для чтения. Иногда нужно, чтобы свойство устанавливалось только при создании объекта и после этого никогда не изменялось.

Это как раз требуется для кофеварки: мощность никогда не меняется.

Для этого нам нужно создать только геттер, но не сеттер:

```javascript
class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }
}

// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

// Мощность: 100W
alert(`Мощность: ${coffeeMachine.power}W`);

coffeeMachine.power = 25; // Error (no setter)
```

**Защищённые поля наследуются**

Если мы унаследуем `class MegaMachine extends CoffeeMachine`, ничто не помешает нам обращаться к `this._waterAmount` или `this._power` из методов нового класса.

Таким образом защищённые методы, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.

## Приватное свойство «#waterLimit»

Приватные поля вошли в стандарт ECMAScript 2022 и реализованы в [подавляющем большинстве браузеров](https://caniuse.com/?search=class%20fields){:target="_blank"}.

Приватные свойства и методы должны начинаться с `#`. Они доступны только внутри класса.

Например, в классе ниже есть приватное свойство `#waterLimit` и приватный метод `#checkWater` для проверки количества воды:

```javascript
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) throw new Error(
      "Отрицательный уровень воды"
    );
    if (value > this.#waterLimit) throw new Error(
      "Слишком много воды"
    );
  }
}

let coffeeMachine = new CoffeeMachine();

// снаружи  нет доступа к приватным методам класса
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error
```

На уровне языка `#` является специальным символом, который означает, что поле приватное. Мы не можем получить к нему доступ извне или из наследуемых классов.

Приватные поля не конфликтуют с публичными. У нас может быть два поля одновременно – приватное `#waterAmount` и публичное `waterAmount`.

Например, давайте сделаем аксессор `waterAmount` для `#waterAmount`:

```javascript
class CoffeeMachine {

  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error(
      "Отрицательный уровень воды"
    );
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;
alert(machine.#waterAmount); // Error
```

В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.

Но если мы унаследуем от `CoffeeMachine`, то мы не получим прямого доступа к `#waterAmount`. Мы будем вынуждены полагаться на геттер/сеттер `waterAmount`:

```javascript
class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    // Error: can only access from CoffeeMachine
    alert( this.#waterAmount );
  }
}
```

Во многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем `CoffeeMachine`, у нас может быть вполне законная причина для доступа к внутренним методам и свойствам. Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.

**Важно:**

Приватные поля особенные.

Обычно мы можем получить доступ к полям объекта с помощью this[name]:

```javascript
class User {
  ...
  sayHi() {
    let fieldName = "name";
    alert(`Hello, ${this[fieldName]}`);
  }
}
```

С приватными свойствами такое невозможно: `this['#name']` не работает. Это ограничение синтаксиса сделано для обеспечения приватности.

## Итог

В терминах ООП отделение внутреннего интерфейса от внешнего называется [инкапсуляция](https://ru.wikipedia.org/wiki/Инкапсуляция_(программирование)){:target="_blank"}.

Это даёт следующие выгоды:

- Защита для пользователей, чтобы они не выстрелили себе в ногу. Если пользователь класса изменит вещи, не предназначенные для изменения извне – последствия непредсказуемы.

- Поддерживаемость. Приватные методы можно безопасно переименовывать, их параметры можно изменять и даже удалять, потому что от них не зависит внешний код. В новой версии вы можете полностью всё переписать, но пользователю будет легко обновиться, если внешний интерфейс остался такой же.

- Сокрытие сложности. Люди обожают использовать простые вещи. По крайней мере, снаружи. Что внутри – это другое дело. Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:

- Защищённые поля имеют префикс `_`. Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны обращаться к полю, начинающемуся с `_`, только из его класса и классов, унаследованных от него.

- Приватные поля имеют префикс `#`. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.
