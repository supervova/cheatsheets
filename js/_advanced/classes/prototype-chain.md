Цепочка прототипов - это способ реализации наследования в JavaScript. Каждый объект в JavaScript имеет ссылку на другой объект, который называется его прототипом. Когда свойство или метод не найдены в текущем объекте, JavaScript пытается найти его в прототипе. Это продолжается, пока не будет найдено свойство или метод, или пока не будет достигнут конец цепочки прототипов.

Все объекты в JavaScript имеют свойство `prototype`. И это тоже объект. Изначально пустой. Благодаря ему объекты могут передавать своим разнообразным потомкам свойства: от общего к частному. Потомки «расширяют» своих предков. Эволюционируют.

Синтаксис наследования цепочки прототипов.

```javascript
class MyChildClass extends MyParentClass { ...}
```

Пример.

```javascript
/**
 * Родительский класс
 */
class Animal {
  constructor(name) {
    this.name = name;
  }

  walkieTalkie() {
    alert(`Меня зовут ${this.name}`);
  }
}

/**
 * Класс-наследник
 */
class Rabbit extends Animal {
  /* В классе-наследнике можно переопределить
  методы родителя. */
  walkieTalkie() {
    /* Методы родителя доступны классу-наследнику
    через конструкцию с кл. словом `super` */
    super.walkieTalkie();
    alert(' и я люблю прыгать');
  }
}

// Меня зовут и я люблю прыгать
new Rabbit('Вася').walk();
```

#### Цепочка прототипов и `getPrototypeOf`

При наследовании через extends формируется стандартная цепочка прототипов. В предыдущем примере методы `Rabbit` находятся в `Rabbit.prototype`, методы `Animal` – в `Animal.prototype`. Обратиться к прототипу предка можно через метод `getPrototypeOf`.

```javascript
if (
  Object.getPrototypeOf(Rabbit)
  === Animal.prototype
) {
  alert('true!');
}
```

#### Конструкторы предка и потомка

Если в классе-потомке не указан свой `constructor`, то используется родительский.

Если же у потомка свой `constructor`, то, чтобы в нём вызвать конструктор родителя, используется синтаксис `super()` с аргументами для родителя.

Вызвать конструктор родителя можно только изнутри конструктора потомка. Иными словами, `super()` нельзя вызвать из произвольного метода.

```javascript
class NewRabbit extends Animal {
  constructor() {
    /* В конструкторе потомка мы обязаны вызвать
    super() до обращения к this. До вызова
    super не существует this. В следующей
    строке была бы ошибка.
    alert(this);

    Вызвать конструктор Animal с аргументом
    'Кроль'.
    То же, что и Animal.call(this, 'Кроль') */
    super('Кроль');

    /* А вот здесь, после вызова super уже можно
    использовать this */
  }
}

// Меня зовут Кроль
new Rabbit().walk();
```

#### Методы встроенного `Object`

☝️🧐 Все объекты наследуют от встроенного Object, и поэтому наследуют такие методы, как `hasOwnProperty()`, `toString()`, `isPrototypeOf()`, `valueOf` и пр. Однако метод `toString`, вызванный из экземпляра возвращает вместо значений свойств слово `Object`, поэтому этот метод переопределяют.

```javascript
Rabbit.prototype.toString = () => {
  alert(`
    Хозяина кролика ${this.name} зовут ${this.owner}
  `);
};
```

До появления конструкций `class`, `constructor` и `super` для создания классов [использовались стандартные функции](/js/advanced-theory.html#topic-classes-deprecated-constructor-function), а для наследования и расширения — исключительно свойство `prototype`.
