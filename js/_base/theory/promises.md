[Промис](https://learn.javascript.ru/promise-basics) (promise; термин не переводится) – это специальный объект, который связывает «создающий» и «потребляющий» код.

- «Создающий» код делает что-то, что занимает время. Например, загружает данные по сети или поставлен на таймер.
- «Потребляющий» код хочет получить результат «создающего» кода, когда тот будет готов.

Такая связь возможна потому, что промис содержит своё состояние:

- `pending` («ожидание»),
- `fulfilled` («выполнено успешно») или `rejected` («выполнено с ошибкой»).

Промис является альтернативой обычной функции, вызывающей один из двух колбэков в зависимости от успешного или неудачного завершения операции.

#### Синтаксис

Создаем промис — вызываем конструктор и передаём в параметры функцию — «создающий» код (другое название — «исполнитель», executor). Она вызывается автоматически и получает два аргумента: `resolve` и `reject`. Это встроенные функции, писать их не нужно. Исполнитель вызовет одну из двух по готовности.

```javascript
/* Стрелочная функция, переданная в экземпляр —
это «создающий» код (может занять время) */
const myPromise = new Promise((myResolve, myReject) => {
  /* Первый аргумент – функция, которая выполняется,
  если промис переходит в состояние  `fulfilled` —
  «выполнен успешно» — и получает  результат. */
  myResolve();

  /* Второй аргумент – функция, которая
  выполняется, если промис переходит в состояние
  «выполнен с ошибкой», и получает объект ошибки */
  myReject();
});

// «Потребляющий» код —ждет смены выполнения промиса
myPromise.then(
  (value) => {
    // код в случае успеха
  },
  (error) => {
    // код в случае ошибки
  }
);
```

Функции-потребители регистрируются (подписываются) с помощью методов `then`, `catch` и `finally`.

#### `then`

Наиболее важный и фундаментальный метод.

```javascript
promise.then(
  (result) => {
    // обработает успешное выполнение
  },
  (error) => { /* обработает ошибку */ }
);
```

Например, вот реакция на успешно выполненный промис.

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result),
  error => alert(error)
);
```

В `then` можно передать только первую, «успешную» функцию.

```javascript
let promise = new Promise(resolve => {
  setTimeout(() => resolve('done!'), 1000);
});

// выведет "done!" спустя одну секунду
promise.then(alert);
```

#### `catch`

Если нужно обработать только ошибку, то используют метод `catch(errorHandlingFunction)`.

```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// выведет "Error: Ошибка!" спустя одну секунду
promise.catch(alert);
```

Того же результата можно добиться, передав в первый, «успешный» параметр `then` значение `null`: `then(null, errorHandlingFunction)`.

#### `finally`

Выполнится, когда промис завершится, независимо от того, успешно или нет. Аналогичен блоку `finally` конструкции `try {...} catch {...}` — см. раздел «Ошибки».

```javascript
new Promise((resolve, reject) => {
/* сделать что-то, что займёт время, и после
вызвать resolve/reject */
}).finally(() => остановить индикатор загрузки)
  .then(
    result => показать результат,
    err => показать ошибку
  )
```

#### Свойства

`Promise.length`, `Promise.prototype`

#### Методы

`Promise.all`, `Promise.race`, `Promise.reject`, `Promise.resolve`
