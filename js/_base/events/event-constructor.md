Можно не только назначать обработчики, но и генерировать события из JavaScript. Это могут быть пользовательские события — например, `menuOpen`, `menuClose` и т.п. — или встроенные: как `click`, `mousedown`. Генерация встроенных событий бывает полезна для автоматического тестирования.

Пользовтели jQuery в своё время генерировали события с помощью метода `trigger()`

#### Базовый конструктор событий

Пользовательские события со своими именами часто создают для улучшения архитектуры, чтобы сообщить о том, что происходит внутри UI-компонентов: меню, слайдеров, каруселей и т.д.

Чтобы сгенерировать событие из кода, вначале надо создать объект события. Базовый конструктор `Event` принимает обязательное имя события и объект `options`:

- `bubbles: true` чтобы событие всплывало.
- `cancelable: true` если нужно, чтобы работал `event.preventDefault()`.

```js
// Всплытие: ловим на document...
document.addEventListener('hello', (event) => {
  alert(`Привет от ${event.target.tagName}`);
});

/* Создаем пользовательское событие
и привязываем к элементу методом `dispatchEvent` */
const myEvent = new Event('hello', { bubbles: true });
elem.dispatchEvent(myEvent);

// Обработчик на document сработает и выведет сообщение.
```

Для генерации пользовательских событий можно также использовать специальный конструктор `CustomEvent`, в опциях которого есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

#### `MouseEvent`, `KeyboardEvent` и другие специальные конструкторы

Для некоторых конкретных типов событий есть свои специфические конструкторы. Они позволяют указать особые свойства для данного типа события: например, `clientX`/`clientY` для события мыши:

- UIEvent
- FocusEvent
- MouseEvent
- WheelEvent
- KeyboardEvent

```js
// Создаем событие
const event = new MouseEvent('click', {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100,
});

alert(event.clientX); // '100'
```

⚠️ Генерировать встроенные браузерные события можно, но, лучше сначала перепроверить свою программу. Часто, потребность в генерации встроенного события свидетельствуют о плохой архитектуре кода.
