События чаще всего зависят друг от друга, и это требует системного подхода к организации обработчиков.

Типичный пример. Пользователь кликает на кнопку и открывает модальное окно. Оно может быть закрыто нажатием клавиши `Esc`. За логику отвечают обработчики двух событий: `click` и `keydown`. Слушатель первого установлен на кнопку. Слушатель второго — на весь `document`.

Обычно мы записываем обработчики последовательно.

```js
const handleClick = () => {
  // Открыть модалку
};

const handleKeydown = (e) => {
  // Закрыть модалку
};

// `buttonEl` — это наша кнопка
buttonEl.addEventListener('click', handleClick);
document.addEventListener(
  'keydown', handleKeydown
);
```

Обработчик `handleKeydown` зависит от `handleClick`, поскольку имеет смысл только тогда, когда модалка открыта. В принципе, можно использовать флаг, чтобы знать, когда окно открыто.

```js
let isModalOpened = false;

const handleClick = () => {
  // Переключаем флаг
  isModalOpened = true;
  // Открываем окно ...
};

const handleKeydown = (e) => {
  // Проверяем открыто ли окно
  if (isModalOpened) {
    // Закрываем окно ...
  }
};
```

Не самое хорошее решение — слишком много кода, и это усложняет поддержку.

#### Более элегантное решение — вложенный обработчик

```js
const handleClick = () => {
  document.addEventListener(
    'keydown', handleKeydown
  );
};
```

Никаких флагов. Код легче читается и поддерживается.
