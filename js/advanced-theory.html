<!DOCTYPE html>
<html lang="ru" prefix="og: http://ogp.me/ns#"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>JavaScript. Теория — углубленное изучение</title>
<meta name="description" content="Условия и циклы {%- include details.html title=&quot;`if...else`&quot; path=&quot;_advanced/control-structures/if-else.md&quot; id=&quot;topic-if-else&quot; -%} {%- include details.html title=&quot;`switch`&quot; path=&quot;_advanced/control-structures/switch.md&quot; id=&quot;topic-switch&quot; -%} {%- include details.html title=&quot;`for`&quot; path=&quot;_advanced/control-structures/loop-for.md&quot; id=&quot;topic-loop-for&quot; -%} Функции {%- include details.html title=&quot;Оператор `return`&quot; path=&quot;_advanced/functions/return.md&quot; id=&quot;topic-functions-return&quot; -%} {%- include details.html title=&quot;Вызов (call) функции&quot; path=&quot;_advanced/functions/call.md&quot; id=&quot;topic-functions-call&quot; -%} {%- include details.html title=&quot;Функция — это объект&quot; path=&quot;_advanced/functions/object.md&quot;...">
<meta name="author" content="Vladimir Nikishin, www.super-mark.ru">
<meta name="apple-mobile-web-app-title" content="Шпоры">
<meta name="theme-color" content="#e5effa"><link rel="canonical" href="https://cheatsheets.super-mark.ru/js/advanced-theory"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Roboto:wght@400;500&display=swap">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs-themes@1.0.0/mono-blue.css">
<link rel="stylesheet" href="/assets/css/style.css?20220805-1313">
</head>
<body>
    <main class="main">
  <h1>JavaScript. Теория — углубленное изучение</h1>
  <input class="input__field is-lg" id="topic-filter" type="text" placeholder="Фильтр записей: введите запрос">

  <section>
  <h2>Условия и циклы</h2><details class="accordion" id="topic-if-else">
  <summary class="accordion__header">
    <h3>`if...else`</h3>
  </summary>
  <div class="accordion__body">
      <h4 id="section">Использование функции в условном выражении</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Необходимые переменные</span>
<span class="kd">const</span> <span class="nx">myAge</span> <span class="o">=</span> <span class="nx">prompt</span><span class="p">(</span><span class="dl">'</span><span class="s1">How old are you?</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">legalDrivingAge</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// Функция, которая будет использована в условии</span>
<span class="kd">const</span> <span class="nx">canIDrive</span> <span class="o">=</span> <span class="p">(</span><span class="nx">age</span><span class="p">,</span> <span class="nx">legalAge</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="nx">legalAge</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="err">  </span><span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Функция в условии</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">canIDrive</span><span class="p">(</span><span class="nx">myAge</span><span class="p">,</span> <span class="nx">legalDrivingAge</span><span class="p">))</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">You can legally drive!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
<span class="err">    </span><span class="dl">'</span><span class="s1">You</span><span class="se">\'</span><span class="s1">ll have to wait a few more years!</span><span class="dl">'</span>
<span class="err">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="section-1">Вложенные условные конструкции</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">yourName</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gender</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// Вложенная конструкция</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">gender</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">male</span><span class="dl">'</span> <span class="o">||</span> <span class="nx">gender</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">result</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Thanks</span><span class="dl">'</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">result</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Please enter male or female.</span><span class="dl">'</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">result</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Tell us both your name and gender.</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="section-2">☝️🧐 Стилистические рекомендации</h4>

      <p>Если в блоке <code class="language-plaintext highlighter-rouge">if</code> выполняется оператор <code class="language-plaintext highlighter-rouge">return</code>, последующий блок <code class="language-plaintext highlighter-rouge">else</code> не нужен. <code class="language-plaintext highlighter-rouge">return</code> внутри блока <code class="language-plaintext highlighter-rouge">else if</code>, следующем за блоком <code class="language-plaintext highlighter-rouge">if</code>, который содержит <code class="language-plaintext highlighter-rouge">return</code>, может быть разделен на несколько блоков <code class="language-plaintext highlighter-rouge">if</code>.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * ⛔️ плохо
 * @return {*}
 */</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * 👍 хорошо
 * @return {*}
 */</span>
<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>

<span class="err">  </span><span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>☝️🧐 Для логического типа используем сокращение — переменные равные <code class="language-plaintext highlighter-rouge">true</code> или <code class="language-plaintext highlighter-rouge">false</code> в сравнении не нуждаются. Для строк и чисел используем явное сравнение.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ⛔️ плохо</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">isValid</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 👍 хорошо</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">isValid</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ⛔️ плохо</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 👍 хорошо</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">name</span> <span class="o">!==</span> <span class="dl">''</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ⛔️ плохо</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">collection</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 👍 хорошо</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">collection</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>В условных операторах, результат выражения переводится в булевый тип по следующим правилам.</p>

      <ul>
        <li><code class="language-plaintext highlighter-rouge">Object</code> = true</li>
        <li><code class="language-plaintext highlighter-rouge">Undefined</code> = false</li>
        <li><code class="language-plaintext highlighter-rouge">Null</code> соответствует false</li>
        <li><code class="language-plaintext highlighter-rouge">Boolean</code> — по значению</li>
        <li>Строка соответствует false, если пустая ‘’, в остальных случаях true</li>
        <li>Число соответствует false, если +0, -0, or <code class="language-plaintext highlighter-rouge">NaN</code>, в остальных случаях true</li>
      </ul>

      <p>☝️🧐 Если управляющий оператор (<code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">while</code> и т.д.) слишком длинный, то каждое (сгруппированное) условие можно поместить на новую строку. Логический оператор должен располагаться в начале строки.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ⛔️ плохо</span>
<span class="k">if</span> <span class="p">((</span><span class="nx">foo</span> <span class="o">===</span> <span class="mi">123</span> <span class="o">||</span> <span class="nx">bar</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">doesItLookGoodWhenItBecomesThatLong</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">isThisReallyHappening</span><span class="p">())</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">thing1</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 👍 хорошо</span>
<span class="k">if</span> <span class="p">(</span>
<span class="err">  </span><span class="p">(</span><span class="nx">foo</span> <span class="o">===</span> <span class="mi">123</span> <span class="o">||</span> <span class="nx">bar</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">)</span>
<span class="err">  </span><span class="o">&amp;&amp;</span> <span class="nx">doesItLookGoodWhenItBecomesThatLong</span><span class="p">()</span>
<span class="err">  </span><span class="o">&amp;&amp;</span> <span class="nx">isThisReallyHappening</span><span class="p">()</span>
<span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">thing1</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-switch">
  <summary class="accordion__header">
    <h3>`switch`</h3>
  </summary>
  <div class="accordion__body">
      <p>☝️🧐 <strong>Использовать фигурные скобки</strong> для <code class="language-plaintext highlighter-rouge">case</code> и <code class="language-plaintext highlighter-rouge">default</code>, если они содержат присвоение значений переменных или объявление класса (так называемые «лексические декларации»).</p>

      <p><strong>Не объявлять</strong> в switch функций. eslint: no-case-declarations, no-inner-declarations</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ⛔️ плохо</span>
<span class="k">switch</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
<span class="err">    </span><span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
<span class="err">    </span><span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">default</span><span class="p">:</span>
<span class="err">    </span><span class="cm">/**
     * JSDoc
     */</span>
<span class="err">    </span><span class="kd">class</span> <span class="nx">C</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 👍 хорошо</span>
<span class="k">switch</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
<span class="err">    </span><span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
<span class="err">    </span><span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
<span class="err">    </span><span class="nx">bar</span><span class="p">();</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">default</span><span class="p">:</span> <span class="p">{</span>
<span class="err">    </span><span class="cm">/**
     * JSDoc
     */</span>
<span class="err">    </span><span class="kd">class</span> <span class="nx">C</span> <span class="p">{}</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="section-3">Примеры</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">switch</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Маловато</span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">В точку!</span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Перебор</span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">default</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Я таких значений не знаю</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Сначала получаем номер дня недели из объекта
Date. Затем присваиваем переменной переменной
значения зависимости от этого номера */</span>
<span class="k">switch</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getDay</span><span class="p">())</span> <span class="p">{</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">6</span><span class="p">:</span>
<span class="err">    </span><span class="nx">text</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Today is Saturday</span><span class="dl">'</span><span class="p">;</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
<span class="err">    </span><span class="nx">text</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Today is Sunday</span><span class="dl">'</span><span class="p">;</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="k">default</span><span class="p">:</span>
<span class="err">    </span><span class="nx">text</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Looking forward to the Weekend</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="case">Группировка <code class="language-plaintext highlighter-rouge">case</code></h4>

      <p>Несколько значений case можно группировать. В примере ниже case 3 и case 5 выполняют один и тот же код</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Верно!</span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>

<span class="err">  </span><span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
<span class="err">  </span><span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Немного ошиблись, бывает.</span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>

<span class="err">  </span><span class="k">default</span><span class="p">:</span>
<span class="err">    </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Странный результат, очень странный</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-loop-for">
  <summary class="accordion__header">
    <h3>`for`</h3>
  </summary>
  <div class="accordion__body">
      <h4 id="for"><code class="language-plaintext highlighter-rouge">for</code></h4>

      <p><strong>Запись в круглых скобках состоит из трех частей</strong>. При этом все три части опциональны.</p>

      <pre><code class="language-txt">for (
  инициализация счетчика;
  проверка условия;
  увеличение/ уменьшение счетчика
)
</code></pre>

      <p><strong>Первая часть</strong> — это, как правило, инициализация переменной цикла / счетчика. Однако в ней могут быть инициализированы и другие переменные. Например…</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">text</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cities</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">text</span> <span class="o">+=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">cities</span><span class="p">}</span><span class="s2"> &lt;br&gt;`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p><strong>Вторая часть — проверка условия</strong>. Она выполняется при каждой итерации цикла. Если условие оказывается ложным, выполнение цикла прерывается. Если есть желание пропустить эту часть, в теле цикла нужно указать break.</p>

      <p><strong>Третья часть — увеличение / уменьшение счетчика</strong>. Оно происходит один раз за итерацию, после выполнения всех команд в ТЕЛЕ цикла. Изменение счетчика чаще всего производят инкрементом <code class="language-plaintext highlighter-rouge">i++</code>. Но можно и декрементом <code class="language-plaintext highlighter-rouge">i--</code>, изменением на указанную цифру <code class="language-plaintext highlighter-rouge">i += 15</code> и т. д.</p>

      <p><code class="language-plaintext highlighter-rouge">👍 хорошо
 &lt; короче/лучше, чем &lt;=</code></p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Сокращенный вариант цикла, только с условием,
без счетчика */</span>
<span class="k">for</span> <span class="p">(;</span><span class="nx">answer</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">forty-two</span><span class="dl">'</span><span class="p">;)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="section-4">Вложенные циклы</h4>

      <p>Обычно вложенные циклы применяются для перебора многомерных массивов.</p>

      <p>Например, когда нужно сложить аккуратно вещи в шкафчике из трех полок, внешним циклом мы перебираем полки: одну за другой. На каждой этапе запускаем вложенный цикл, в процессе которого перебираем и раскладываем вещи.</p>

      <p>Те же процессы происходят, когда собираем колоду карт: поочереди масть за мастью — добавляем в каждой группе все номиналы. Или когда собираем многоуровневое главное меню сайта.</p>

      <p>Никаких ограничений: <code class="language-plaintext highlighter-rouge">for</code> в <code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">for</code> в <code class="language-plaintext highlighter-rouge">while</code>, наоборот, с любым уровнем вложенности.</p>

      <p><strong>Пример.</strong> Три раза подряд посчитать от 1 до 5.</p>

      <p>☝️🧐 <code class="language-plaintext highlighter-rouge">i</code> и <code class="language-plaintext highlighter-rouge">j</code> — стандартные названия переменных для циклов. Эта традиция идет от тех времен, когда объем программы был ограничен (а код пробивался на перфокартах) и у коротких имен были преимущества перед значащими названиями. Теперь это всего лишь традиция, но всего лишь исключение из правила о выборе осмысленных имен переменных.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">j</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>😎 <strong>Трюк</strong>. Заполнение массива нулями — с тем, чтобы потом суммировать их с числами, результатами вычислений. Сложение пустой позиций с числом дает в результате undefined.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Пять раз…</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="cm">/* …добавляем в созданный в начале документа
  массив по 0 — получаем массив из 5 нулей */</span>
<span class="err">  </span><span class="nx">myArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p><strong>Практический пример.</strong> Подсчет вероятности выпадения дубля на двух костях.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isDouble</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">totalCombos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Каждая из шести сторон одной кости…</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="cm">/* …Может составить пару с шестью сторонами
  другой: 6x6 */</span>
<span class="err">  </span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="cm">/* Увеличиваем счетчик дублей, если значения
    сторон совпадают */</span>
<span class="err">    </span><span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
<span class="err">      </span><span class="nx">isDouble</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="err">    </span><span class="p">}</span>
<span class="err">    </span><span class="nx">totalCombos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Вероятность — количество дублей на общее
количество комбинаций */</span>
<span class="kd">const</span> <span class="nx">probability</span> <span class="o">=</span> <span class="nx">isDouble</span> <span class="o">/</span> <span class="nx">totalCombos</span><span class="p">;</span>
</code></pre></div>      </div>
    </div>
</details>
</section>

<section>
  <h2>Функции</h2><details class="accordion" id="topic-functions-return">
  <summary class="accordion__header">
    <h3>Оператор `return`</h3>
  </summary>
  <div class="accordion__body">
      <p>Завершает выполнение текущей функции и возвращает её значение.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">square</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="err">  </span><span class="cm">/* return может находиться в любом месте тела
  функции. Но после этой директивы код уже не будет
  выполняться. */</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">В консоли это не появится</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Значение demo будет равняться 9</span>
<span class="kd">const</span> <span class="nx">demo</span> <span class="o">=</span> <span class="nx">square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Вызовов <code class="language-plaintext highlighter-rouge">return</code> может быть несколько.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">checkAge</span><span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">age</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">А родители разрешили?</span><span class="dl">'</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="nx">prompt</span><span class="p">(</span><span class="dl">'</span><span class="s1">Сколько вам лет?</span><span class="dl">'</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span> <span class="nx">checkAge</span><span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span> <span class="dl">'</span><span class="s1">Доступ получен</span><span class="dl">'</span> <span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span> <span class="dl">'</span><span class="s1">Доступ закрыт</span><span class="dl">'</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>Возможно использовать <code class="language-plaintext highlighter-rouge">return</code> и без значения. Это приведёт к немедленному выходу из функции.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showMovie</span><span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">checkAge</span><span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>

<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Вам показывается кино</span><span class="dl">'</span><span class="p">);</span>
<span class="err">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p><strong>Использование <code class="language-plaintext highlighter-rouge">return</code> необязательно.</strong> Если функция не возвращает значение, а, например, просто назначает CSS-класс, можно не использовать <code class="language-plaintext highlighter-rouge">return</code>.</p>

      <p>☝️🧐  Надо помнить, что в если попытаться получить значение такой функции, оно будет <code class="language-plaintext highlighter-rouge">undefined</code>.</p>

      <p>☝️🧐  Хотя некоторые разработчики используют пустой <code class="language-plaintext highlighter-rouge">return</code> в конце функции для явного завершения выполнения, <a href="https://eslint.org/docs/rules/no-useless-return">Airbnb не рекомендует этого делать</a>.</p>

      <p>🤓 В Си подобные функции начинаются с объявления типа <code class="language-plaintext highlighter-rouge">void</code>.</p>
    </div>
</details>
<details class="accordion" id="topic-functions-call">
  <summary class="accordion__header">
    <h3>Вызов (call) функции</h3>
  </summary>
  <div class="accordion__body">
      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myFunc</span><span class="p">(</span><span class="dl">'</span><span class="s1">аргумент в param1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">аргумент в param2</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Функции можно вызывать в других конструкциях, например в условной…</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">myFunc</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// code…;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// code…;</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>Также функции можно вызвать в других функциях.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Пример № 1</span>
<span class="kd">const</span> <span class="nx">square</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">cube</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">square</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>

<span class="c1">// Пример № 2</span>
<span class="kd">const</span> <span class="nx">isMultipleOfThree</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>      </div>

      <p>Интересный пример использования оператора <code class="language-plaintext highlighter-rouge">!</code> — логического «НЕ». Число сначала передаётся в первую функцию <code class="language-plaintext highlighter-rouge">isMultipleOfThree</code>. То, что остаток деления на 3 не равен 0 обозначается ! перед использованной функцией</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">isNotMultipleOfThree</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">isMultipleOfThree</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-object">
  <summary class="accordion__header">
    <h3>Функция — это объект</h3>
  </summary>
  <div class="accordion__body">
      <p>Функция, как почти все в JS — это объект. И у этого объекта есть свойства и методы. Например, свойство <code class="language-plaintext highlighter-rouge">name</code> содержит имя, указанное при объявлении функции, либо переменную / метод, в которую она сохранена.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// myFunc.name == 'myFunc'</span>
<span class="kd">function</span> <span class="nx">myFunc</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// mySecondFunc.name == "mySecondFunc"</span>
<span class="kd">const</span> <span class="nx">mySecondFunc</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>

<span class="cm">/* Метод toString возвращает код функции в виде
строки */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myFunc</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-first-class">
  <summary class="accordion__header">
    <h3>Функции высшего порядка (или функции первого класса)</h3>
  </summary>
  <div class="accordion__body">
      <ul>
        <li>Могут быть присвоены переменным или сохранены в объекте.</li>
        <li>Могут передаваться в качестве аргументов другим функциям.</li>
        <li>Другие функции могут возвращать first-class function, как результат.</li>
      </ul>

      <p>В практическом смысле это означает систему вложений (includ’ов) для функций.</p>

      <p>В JS все функции — высшего порядка (первоклассные).</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Функция которая будет передана в аргументе
 * следующей функции - «инклуд»
 */</span>
<span class="kd">function</span> <span class="nx">hawaiianTranslator</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">let</span> <span class="nx">translation</span><span class="p">;</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">word</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">translation</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Aloha</span><span class="dl">'</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">word</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Goodbye</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">translation</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Aloha</span><span class="dl">'</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>

<span class="err">  </span><span class="k">return</span> <span class="nx">translation</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * «Мастер-функция» которая получит в аргументе
 * «функцию-инклуд»
 *
 * @param {function} translator — функция, которая
 * переводит полученный аргумент.
 */</span>
<span class="kd">function</span> <span class="nx">sayIt</span><span class="p">(</span><span class="nx">translator</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="cm">/* «Функция-инклуд», переданная в аргументе
  translator, вызывается, и полученное значение
  сохраняется в переменной phrase. */</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">phrase</span> <span class="o">=</span> <span class="nx">translator</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="nx">phrase</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Вызываем sayIt, передавая ей в аргументе
«функцию-инклуд» */</span>
<span class="nx">sayIt</span><span class="p">(</span><span class="nx">hawaiianTranslator</span><span class="p">);</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-local-variables">
  <summary class="accordion__header">
    <h3>Локальные переменные</h3>
  </summary>
  <div class="accordion__body">
      <p>Переменные, объявленные внутри функции, недоступны за пределами ее фигурных скобок (область видимости функции). Они создаются в момент вызова функции и очищаются после выполнения кода функции.</p>

      <p>☝️🧐 Функции и объекты созданные внутри других функций, также ограничены локальной областью видимости и недоступны извне.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// code here can NOT use carName</span>

<span class="kd">function</span> <span class="nx">myFunc</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">carName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Volvo</span><span class="dl">'</span><span class="p">;</span>
<span class="err">  </span><span class="c1">// code here CAN use carName</span>
<span class="p">}</span>

<span class="c1">// code here can NOT use carName</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-parameters-default-values">
  <summary class="accordion__header">
    <h3>Параметры по умолчанию</h3>
  </summary>
  <div class="accordion__body">
      <p>Если функция не дополучает аргументов, пропущенные значения становятся <code class="language-plaintext highlighter-rouge">undefined</code>. Иногда это не страшно, но иногда чревато ошибками. Решают проблему значения по умолчанию. Присваиваются через знак равенства.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myFunc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Икс</span><span class="dl">'</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</code></pre></div>      </div>

      <p>Параметры со значениями по умолчанию пишутся в конце, после обычных параметров — так чтобы функция возвращала <code class="language-plaintext highlighter-rouge">undefined</code> только в случае пропуска всех аргументов.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * JSDoc
 *
 * @param {string} name
 * @param {number} height
 * @param {number} weight
 */</span>
<span class="kd">const</span> <span class="nx">sayMyHeight</span> <span class="o">=</span> <span class="p">(</span>
<span class="err">  </span><span class="nx">name</span><span class="p">,</span>
<span class="err">  </span><span class="nx">height</span> <span class="o">=</span> <span class="mi">186</span><span class="p">,</span>
<span class="err">  </span><span class="nx">weight</span> <span class="o">=</span> <span class="mi">96</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="s2">`
    Hi! My name is </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">. My height
    is </span><span class="p">${</span><span class="nx">height</span><span class="p">}</span><span class="s2">cm and my weight is </span><span class="p">${</span><span class="nx">weight</span><span class="p">}</span><span class="s2">kg.
  `</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">sayMyHeight</span><span class="p">(</span><span class="dl">'</span><span class="s1">Vova</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Параметры по умолчанию могут быть любого типа: строками, числами, булевыми значениями, объектами…</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * JSDoc
 * @param {object} opts
 */</span>
<span class="kd">function</span> <span class="nx">findProducts</span><span class="p">(</span>
<span class="err">  </span><span class="nx">opts</span> <span class="o">=</span> <span class="p">{</span> <span class="na">minPrice</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">maxPrice</span><span class="p">:</span> <span class="mi">20</span> <span class="p">},</span>
<span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">opts</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// { minPrice: 10, maxPrice: 20 }</span>
<span class="nx">findProducts</span><span class="p">();</span>

<span class="cm">/* {}. Даже пустой объект в аргументе заменит
значение по умолчанию */</span>
<span class="nx">findProducts</span><span class="p">({});</span>
</code></pre></div>      </div>

      <p>…и выражениями.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * JSDoc
 * @param {function} who
 */</span>
<span class="kd">function</span> <span class="nx">sayHi</span><span class="p">(</span>
<span class="nx">who</span> <span class="o">=</span> <span class="nx">getCurrentUser</span><span class="p">().</span><span class="nx">toUpperCase</span><span class="p">()</span>
<span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="s2">`Привет, </span><span class="p">${</span><span class="nx">who</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Привет, Вася</span>
<span class="nx">sayHi</span><span class="p">();</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-anonymous">
  <summary class="accordion__header">
    <h3>Анонимные функции</h3>
  </summary>
  <div class="accordion__body">
      <p>Анонимная функция (еще можно встретить название «лямбды») — функция без имени. Применяется обычно тогда, когда функция используется лишь однажды. Например, как в примерах ниже, функция-обработчик загрузки страницы. Добавляется в функциональном выражении после знака равенства или в параметрах другой функции.</p>

      <p>Разработчики Airbnb предлагают заменять анонимные функции «старого образца» <a href="https://github.com/leonidlebedev/javascript-airbnb#стрелочные-функции">функциями-стрелками</a>.</p>

      <h4 id="section-5">Пример. Замена именованной функции анонимной…</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handler</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Yeah, that page loaded!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>

<span class="cm">/* Убрать имя переменной handler
Назначить свойству window.onload функциональное
выражение */</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Yeah, that page loaded!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Или так</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// code; event can be 'resize'  too</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-arrow">
  <summary class="accordion__header">
    <h3>Стрелочные функции</h3>
  </summary>
  <div class="accordion__body">
      <p>Синтаксис функции через «стрелку» <code class="language-plaintext highlighter-rouge">=&gt;</code>, без ключевого слова <code class="language-plaintext highlighter-rouge">function</code> и в простых, однострочных случаях без ключевого слова  <code class="language-plaintext highlighter-rouge">return</code>.</p>

      <p>Компактность функций-стрелок значительно облегчает чтение кода. Но главная особенность стрелочных функций в другом. <strong>У них нет своего <code class="language-plaintext highlighter-rouge">this</code>.</strong> Если происходит обращение к <code class="language-plaintext highlighter-rouge">this</code>, его значение берётся снаружи, из внешней функции.</p>

      <p>Функции-стрелки предназначены для небольшого кода (например, обратного вызова), который не имеет своего контекста, выполняясь в родительском.</p>

      <p>В примере внутри <code class="language-plaintext highlighter-rouge">forEach</code> использована стрелочная функция. И это значит, что <code class="language-plaintext highlighter-rouge">this.title</code> в ней будет иметь точно такое же значение, как в методе <code class="language-plaintext highlighter-rouge">showList</code> — <code class="language-plaintext highlighter-rouge">group.title</code>.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">group</span> <span class="o">=</span> <span class="p">{</span>
<span class="err">  </span><span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Наш курс</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="na">students</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Вася</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Петя</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Даша</span><span class="dl">'</span><span class="p">],</span>

<span class="err">  </span><span class="nx">showList</span><span class="p">()</span> <span class="p">{</span>
<span class="err">    </span><span class="k">this</span><span class="p">.</span><span class="nx">students</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
<span class="err">      </span><span class="c1">// стрелочная функция, в которой this тот</span>
<span class="err">      </span><span class="c1">// же, что и у родительского метода</span>
<span class="err">      </span><span class="nx">student</span> <span class="o">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="s2">: student`</span><span class="p">),</span>
<span class="err">    </span><span class="p">);</span>
<span class="err">  </span><span class="p">},</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p>⚠️ <strong>Стрелочные функции не надо писать везде.</strong> Главным образом — там, где нужно сохранить контекст родителя: обработчиках событий, ajax-запросах, анимации (<code class="language-plaintext highlighter-rouge">setInterval</code>, <code class="language-plaintext highlighter-rouge">setTimeout</code>). То есть, <strong>когда функция передается, как аргумент в другую функцию или встроенный метод</strong>.</p>

      <p>⛔️ Стрелочные функции не могут быть использованы как конструкторы, с <code class="language-plaintext highlighter-rouge">new</code> — потому что у них нет <code class="language-plaintext highlighter-rouge">this</code>. У функций-стрелок нет свойства <code class="language-plaintext highlighter-rouge">prototype</code>.</p>

      <h4 id="section-6">Простейший вариант стрелочной функции</h4>

      <p>Слева от <code class="language-plaintext highlighter-rouge">=&gt;</code> находится параметр (<code class="language-plaintext highlighter-rouge">x</code> в данном случае), а справа – выражение, которое нужно вернуть. Без слова <code class="language-plaintext highlighter-rouge">return</code> — в кратком синтаксисе стрелочных функций результат возвращается без лишних формальностей.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myFunc</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Сейчас функция myFunc вернет 2</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">myFunc</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// Та же функция в традиционном синтаксисе:</span>
<span class="kd">const</span> <span class="nx">myFunc2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>      </div>

      <p>Если аргументов несколько, то нужно обернуть их в скобки ()</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>

<span class="c1">// Функция sum вернет 3</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</code></pre></div>      </div>

      <p>Если нужно задать функцию без аргументов, используются пустые скобки.</p>

      <p>В примере вызов <code class="language-plaintext highlighter-rouge">getTime()</code> будет возвращать текущий час.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getTime</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getHours</span><span class="p">()}</span><span class="s2">:`</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">getTime</span><span class="p">());</span>
</code></pre></div>      </div>

      <p>Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getTime</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">hours</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">getHours</span><span class="p">();</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">minutes</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">getMinutes</span><span class="p">();</span>
<span class="err">  </span><span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nx">hours</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">minutes</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p>☝️🧐 Заметим, что как только тело функции оборачивается в {…}, то её результат уже не возвращается автоматически, как в кратком синтаксисе. Такой функции нужен явный <code class="language-plaintext highlighter-rouge">return</code>, если, конечно, нужно что-либо возвратить.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myFunc3</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">myFunc4</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">newSum</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>

<span class="err">  </span><span class="c1">// Здесь нужно явно вернуть результат</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">newSum</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p><strong>Примеры</strong> использования стрелочных функций для обратного вызова.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myArr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="cm">/* В методе Array.sort используем стрелочную
функцию обратного вызова. Такая запись –
коротка и понятна… */</span>
<span class="kd">const</span> <span class="nx">sorted</span> <span class="o">=</span> <span class="nx">myArr</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">sorted</span><span class="p">);</span> <span class="c1">// 3, 5, 8</span>

<span class="cm">/* В gulpfil'e функции-стрелки также используются
для обратного вызова */</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="dl">'</span><span class="s1">twig</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span>
<span class="err">  </span><span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">(</span><span class="dl">'</span><span class="s1">/src/*.twig</span><span class="dl">'</span><span class="p">)</span>
<span class="err">    </span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="dl">'</span><span class="s1">/dist</span><span class="dl">'</span><span class="p">)),</span>
<span class="p">);</span>
</code></pre></div>      </div>

      <h4 id="arguments">У функций-стрелок нет переменной <code class="language-plaintext highlighter-rouge">arguments</code></h4>

      <p>В JavaScript функции в традиционном синтаксисе может быть вызвана с произвольным количеством аргументов. Переданные аргументы сохраняются после вызова функции в псевдомассив <code class="language-plaintext highlighter-rouge">arguments</code> и становятся доступны по номерам: <code class="language-plaintext highlighter-rouge">arguments[0]</code>, <code class="language-plaintext highlighter-rouge">arguments[1]</code>…</p>

      <p>Но они могут использовать псевдомассив аргументов внешней традиционной функции.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">myFunc5</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">showArg</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="err">  </span><span class="cm">/* Вызов showArg() вернет «Ты это видел?»,
  получив его из аргументов myFunc5 */</span>
<span class="err">  </span><span class="nx">showArg</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">myFunc5</span><span class="p">(</span><span class="dl">'</span><span class="s1">Ты это видел?</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-callback">
  <summary class="accordion__header">
    <h3>Функция обратного вызова, callback</h3>
  </summary>
  <div class="accordion__body">
      <p>Синтаксис функции через «стрелку» <code class="language-plaintext highlighter-rouge">=&gt;</code>, без ключевого слова <code class="language-plaintext highlighter-rouge">function</code> и в простых, однострочных случаях без ключевого слова  <code class="language-plaintext highlighter-rouge">return</code>.</p>

      <p>Компактность функций-стрелок значительно облегчает чтение кода. Но главная особенность стрелочных функций в другом. <strong>У них нет своего <code class="language-plaintext highlighter-rouge">this</code>.</strong> Если происходит обращение к <code class="language-plaintext highlighter-rouge">this</code>, его значение берётся снаружи, из внешней функции.</p>

      <p>Функции-стрелки предназначены для небольшого кода (например, обратного вызова), который не имеет своего контекста, выполняясь в родительском.</p>

      <p>В примере внутри <code class="language-plaintext highlighter-rouge">forEach</code> использована стрелочная функция. И это значит, что <code class="language-plaintext highlighter-rouge">this.title</code> в ней будет иметь точно такое же значение, как в методе <code class="language-plaintext highlighter-rouge">showList</code> — <code class="language-plaintext highlighter-rouge">group.title</code>.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">group</span> <span class="o">=</span> <span class="p">{</span>
<span class="err">  </span><span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Наш курс</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="na">students</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Вася</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Петя</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Даша</span><span class="dl">'</span><span class="p">],</span>

<span class="err">  </span><span class="nx">showList</span><span class="p">()</span> <span class="p">{</span>
<span class="err">    </span><span class="k">this</span><span class="p">.</span><span class="nx">students</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
<span class="err">      </span><span class="c1">// стрелочная функция, в которой this тот</span>
<span class="err">      </span><span class="c1">// же, что и у родительского метода</span>
<span class="err">      </span><span class="nx">student</span> <span class="o">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="s2">: student`</span><span class="p">),</span>
<span class="err">    </span><span class="p">);</span>
<span class="err">  </span><span class="p">},</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p>⚠️ <strong>Стрелочные функции не надо писать везде.</strong> Главным образом — там, где нужно сохранить контекст родителя: обработчиках событий, ajax-запросах, анимации (<code class="language-plaintext highlighter-rouge">setInterval</code>, <code class="language-plaintext highlighter-rouge">setTimeout</code>). То есть, <strong>когда функция передается, как аргумент в другую функцию или встроенный метод</strong>.</p>

      <p>⛔️ Стрелочные функции не могут быть использованы как конструкторы, с <code class="language-plaintext highlighter-rouge">new</code> — потому что у них нет <code class="language-plaintext highlighter-rouge">this</code>. У функций-стрелок нет свойства <code class="language-plaintext highlighter-rouge">prototype</code>.</p>

      <h4 id="section-7">Простейший вариант стрелочной функции</h4>

      <p>Слева от <code class="language-plaintext highlighter-rouge">=&gt;</code> находится параметр (<code class="language-plaintext highlighter-rouge">x</code> в данном случае), а справа – выражение, которое нужно вернуть. Без слова <code class="language-plaintext highlighter-rouge">return</code> — в кратком синтаксисе стрелочных функций результат возвращается без лишних формальностей.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myFunc</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Сейчас функция myFunc вернет 2</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">myFunc</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// Та же функция в традиционном синтаксисе:</span>
<span class="kd">const</span> <span class="nx">myFunc2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>      </div>

      <p>Если аргументов несколько, то нужно обернуть их в скобки ()</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>

<span class="c1">// Функция sum вернет 3</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</code></pre></div>      </div>

      <p>Если нужно задать функцию без аргументов, используются пустые скобки.</p>

      <p>В примере вызов <code class="language-plaintext highlighter-rouge">getTime()</code> будет возвращать текущий час.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getTime</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getHours</span><span class="p">()}</span><span class="s2">:`</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">getTime</span><span class="p">());</span>
</code></pre></div>      </div>

      <p>Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getTime</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">hours</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">getHours</span><span class="p">();</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">minutes</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">getMinutes</span><span class="p">();</span>
<span class="err">  </span><span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nx">hours</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">minutes</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p>☝️🧐 Заметим, что как только тело функции оборачивается в {…}, то её результат уже не возвращается автоматически, как в кратком синтаксисе. Такой функции нужен явный <code class="language-plaintext highlighter-rouge">return</code>, если, конечно, нужно что-либо возвратить.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myFunc3</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">myFunc4</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">newSum</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>

<span class="err">  </span><span class="c1">// Здесь нужно явно вернуть результат</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">newSum</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p><strong>Примеры</strong> использования стрелочных функций для обратного вызова.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myArr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="cm">/* В методе Array.sort используем стрелочную
функцию обратного вызова. Такая запись –
коротка и понятна… */</span>
<span class="kd">const</span> <span class="nx">sorted</span> <span class="o">=</span> <span class="nx">myArr</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">sorted</span><span class="p">);</span> <span class="c1">// 3, 5, 8</span>

<span class="cm">/* В gulpfil'e функции-стрелки также используются
для обратного вызова */</span>
<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="dl">'</span><span class="s1">twig</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span>
<span class="err">  </span><span class="nx">gulp</span><span class="p">.</span><span class="nx">src</span><span class="p">(</span><span class="dl">'</span><span class="s1">/src/*.twig</span><span class="dl">'</span><span class="p">)</span>
<span class="err">    </span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">gulp</span><span class="p">.</span><span class="nx">dest</span><span class="p">(</span><span class="dl">'</span><span class="s1">/dist</span><span class="dl">'</span><span class="p">)),</span>
<span class="p">);</span>
</code></pre></div>      </div>

      <h4 id="arguments-1">У функций-стрелок нет переменной <code class="language-plaintext highlighter-rouge">arguments</code></h4>

      <p>В JavaScript функции в традиционном синтаксисе может быть вызвана с произвольным количеством аргументов. Переданные аргументы сохраняются после вызова функции в псевдомассив <code class="language-plaintext highlighter-rouge">arguments</code> и становятся доступны по номерам: <code class="language-plaintext highlighter-rouge">arguments[0]</code>, <code class="language-plaintext highlighter-rouge">arguments[1]</code>…</p>

      <p>Но они могут использовать псевдомассив аргументов внешней традиционной функции.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">myFunc5</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">showArg</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="err">  </span><span class="cm">/* Вызов showArg() вернет «Ты это видел?»,
  получив его из аргументов myFunc5 */</span>
<span class="err">  </span><span class="nx">showArg</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">myFunc5</span><span class="p">(</span><span class="dl">'</span><span class="s1">Ты это видел?</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-parameters-destructuring">
  <summary class="accordion__header">
    <h3>Деструктуризация в параметрах</h3>
  </summary>
  <div class="accordion__body">
      <p>См. также <a href="#topic-objects-destructuring">деструктурирующее присваивание или просто деструктуризацию</a></p>

      <p>Деструктуризация в параметрах — это возможность функции получать значения из объекта или массива, переданного в параметры. Для этого параметры функции заключаются в фигурные скобки, как объект.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showMenu</span><span class="p">({</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="p">})</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">title</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">width</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">height</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
<span class="err">  </span><span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Меню</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="na">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
<span class="err">  </span><span class="na">height</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Объект options будет разбит на переменные.
В диалог будет выведено «Меню 100 200» */</span>
<span class="nx">showMenu</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Можно использовать деструктуризацию со значениями по умолчанию.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showNewMenu</span><span class="p">({</span>
<span class="err">  </span><span class="nx">title</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Заголовок</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="nx">width</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="err">  </span><span class="nx">height</span> <span class="o">=</span> <span class="mi">200</span>
<span class="p">})</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">title</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">width</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">height</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* И в таком случае можно передавать объект только
с измененным значением */</span>
<span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
<span class="err">  </span><span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Меню</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Меню 100 200</span>
<span class="nx">showNewMenu</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Чтобы функция могла быть вызвана вообще без аргументов, нужно добавить ей параметр по умолчанию — пустой объект, пустые фигурные скобки после объекта с параметрами по умолчанию и знака равенства.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showThirdMenu</span><span class="p">({</span>
<span class="err">  </span><span class="nx">title</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Заголовок</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="nx">w</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="err">  </span><span class="nx">h</span> <span class="o">=</span> <span class="mi">200</span>
<span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">title</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">w</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">h</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Заголовок 100 200</span>
<span class="nx">showThirdMenu</span><span class="p">();</span>
</code></pre></div>      </div>
    </div>
</details>
<details class="accordion" id="topic-functions-rest-parameters-spread-operator">
  <summary class="accordion__header">
    <h3>Остаточные параметры, оператор расширения и псевдомассив `arguments`</h3>
  </summary>
  <div class="accordion__body">
      <p>В JS-функции можно передавать произвольное количество параметров в виде массива. Как в пользовательские, так и в некоторые встроенные методы. Например:</p>

      <p><code class="language-plaintext highlighter-rouge">Math.max(...numbers)</code></p>

      <h4 id="rest-">Остаточные (или rest) параметры</h4>

      <p>Вызывать функцию можно с любым количеством аргументов. Даже если она определена с одним параметром, а в нее передали десять, ошибки не будет. Просто 9 аргументов не будут использованы в расчетах, но и не пропадут бесследно — сохранятся в пседомассиве <code class="language-plaintext highlighter-rouge">arguments</code>.</p>

      <p><strong>Остаточные параметры</strong> принимают множество значений, которые интерпретируются функцией, как массив.</p>

      <p>Записываются как произвольное имя после трех точек. Может быть, как единственным параметром, так и одним из нескольких. Во втором случае записывается последним.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * JSDoc
 * @param {string} name
 * @param {*} marks
 */</span>
<span class="kd">const</span> <span class="nx">pupil</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="p">...</span><span class="nx">marks</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">marks</span><span class="p">);</span>
<span class="p">};</span>


<span class="cm">/* Первый аргумент передается в параметр name.
Остальные — в оператор расширения …marks */</span>
<span class="nx">pupil</span><span class="p">(</span><span class="dl">'</span><span class="s1">Вова</span><span class="dl">'</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div>      </div>

      <h4 id="section-8">Пример  №2</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">abccc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">...</span><span class="nx">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="err">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* В консоль будет выведены поочередно 'one',
'two', ['three', 'four', 'five'] */</span>
<span class="nx">abccc</span><span class="p">(</span><span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">two</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">three</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">four</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">five</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>      </div>

      <h4 id="section-9">Пример  №3</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showName</span><span class="p">(</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">firstName</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">lastName</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">rest</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* В диалог будет выведено: Юлий Цезарь -
Император Рима. В rest попадёт массив всех
аргументов, начиная с третьего. Собранные
в rest данные станут настоящим массивом,
с методами map, forEach и пр. */</span>
<span class="nx">showName</span><span class="p">(</span><span class="dl">'</span><span class="s1">Юлий</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Цезарь</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Император</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Рима</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>      </div>

      <h4 id="spread-">Оператор расширения (spread-оператор)</h4>

      <p>Если троеточие в параметрах — признак остаточных параметров. То троеточие в caller’е указывает на оператор расширения или спред-оператор. Он позволяет передавать в функцию массив.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myArr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>

<span class="cm">/* Вызов метода max с оператором расширения
аналогичен Math.max(3, 5, 1) — оператор
"раскрывает" массив в список аргументов) */</span>
<span class="nx">alert</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">myArr1</span><span class="p">));</span>
</code></pre></div>      </div>

      <p>Этим же способом мы можем передать несколько итерируемых объектов:</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myArr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>

<span class="nx">alert</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">myArr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">myArr2</span><span class="p">));</span>
</code></pre></div>      </div>

      <p>Мы можем комбинировать оператор расширения с обычными значениями:</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">alert</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">...</span><span class="nx">myArr1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="nx">myArr2</span><span class="p">,</span> <span class="mi">25</span><span class="p">));</span> <span class="c1">// 25</span>
</code></pre></div>      </div>

      <p>Оператор расширения можно использовать и для слияния массивов:</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">merged</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...</span><span class="nx">myArr1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="nx">myArr2</span><span class="p">];</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">merged</span><span class="p">);</span> <span class="c1">// 0, 3, 5, 1, 8, 3, -8, 1</span>
</code></pre></div>      </div>

      <h4 id="spread-----">Использование spread-оператора для создания копии массива</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">shallowCopy</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">myArr1</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">anotherShallowCopy</span> <span class="o">=</span> <span class="p">[</span>
<span class="err">  </span><span class="p">...</span><span class="nx">myArr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">myArr2</span><span class="p">,</span> <span class="mi">41</span>
<span class="p">];</span>
</code></pre></div>      </div>

      <p>Spread-оператор, также, как и метод <code class="language-plaintext highlighter-rouge">assign()</code> создают так называемую мелкую копию (<code class="language-plaintext highlighter-rouge">shallow copy</code>). Это означает, что при дублировании вложенных объектов в новый объект будет скопирован полностью только первый уровень. Вместо вложенных объектов будут добавлены ссылки на них в «подлиннике».</p>

      <p>☝️🧐  Чтобы полностью дублировать вложенные свойства (методы, в принципе, нельзя), используют методы JSON <code class="language-plaintext highlighter-rouge">stringify</code> (конвертация в строку) и <code class="language-plaintext highlighter-rouge">parse</code>.</p>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">source</span> <span class="o">=</span>
<span class="p">{</span>
<span class="err">  </span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="err">  </span><span class="na">b</span><span class="p">:</span> <span class="p">{</span>
<span class="err">    </span><span class="na">c</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="err">  </span><span class="p">},</span>
<span class="p">};</span>
<span class="kd">let</span> <span class="nx">dest</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span>
</code></pre></div>      </div>

      <h3 id="spread------">Spread-оператор работает с любыми перебираемыми объектами</h3>

      <p>В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, но он работает с любым перебираемым объектом.</p>

      <p>Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Привет</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">([...</span><span class="nx">str</span><span class="p">]);</span> <span class="c1">// П,р,и,в,е,т</span>
</code></pre></div>      </div>

      <p>Оператор расширения перебирает строку как последовательность символов, поэтому из <code class="language-plaintext highlighter-rouge">...str</code> получается “П”, “р”, “и”, “в”, “е”, “т”. Получившиеся символы собираются в массив при помощи стандартного объявления массива, через квадратные скобки — <code class="language-plaintext highlighter-rouge">[...str]</code>.</p>

      <p>Впрочем, задачу перевода разных данных в массив лучше выполнять более универсальным методом <code class="language-plaintext highlighter-rouge">Array.from</code>. Он работает не только с итерируемыми объектами (такими, как строка), но и с псевдомассивами (такими, как <code class="language-plaintext highlighter-rouge">NodeList</code>).</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">alert</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">str</span><span class="p">));</span> <span class="c1">// П,р,и,в,е,т</span>
</code></pre></div>      </div>

      <h4 id="arguments------">Объект <code class="language-plaintext highlighter-rouge">arguments</code> — устаревший способ доступа к аргументам</h4>

      <p>Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью псевдомассива <code class="language-plaintext highlighter-rouge">arguments</code>. Хотя способ всё ещё работает, мы можем найти его в старом коде.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showName</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span> <span class="p">);</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
<span class="err">  </span><span class="nx">alert</span><span class="p">(</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>

<span class="err">  </span><span class="c1">// Объект arguments можно перебирать</span>
<span class="err">  </span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">arg</span> <span class="k">of</span> <span class="nx">arguments</span><span class="p">)</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Вывод: 2, Юлий, Цезарь</span>
<span class="nx">showName</span><span class="p">(</span><span class="dl">"</span><span class="s2">Юлий</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Цезарь</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 1, Вова, undefined (второго аргумента нет)</span>
<span class="nx">showName</span><span class="p">(</span><span class="dl">"</span><span class="s2">Вова</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Хотя <code class="language-plaintext highlighter-rouge">arguments</code> можно перебирать, псевдомассив не поддерживает методы массивов, например, <code class="language-plaintext highlighter-rouge">map()</code>.</p>

      <p>К тому же, <code class="language-plaintext highlighter-rouge">arguments</code> всегда содержит все аргументы функции — нельзя получить их часть. А остаточные параметры позволяют это сделать.</p>

      <p>☝️🧐 Стрелочные функции не имеют <code class="language-plaintext highlighter-rouge">arguments</code>. Если мы обратимся к <code class="language-plaintext highlighter-rouge">arguments</code> из стрелочной функции, то получим аргументы внешней «нормальной» функции.</p>

      <p>Соответственно, для более удобной работы с аргументами <strong>лучше использовать остаточные параметры</strong>.</p>
    </div>
</details>
<details class="accordion" id="topic-functions-closure">
  <summary class="accordion__header">
    <h3>Замыкание (closure) и самовызывающиеся функции</h3>
  </summary>
  <div class="accordion__body">
      <p>Замыкание — вложенная функция, имеющая доступ к переменным внешних функций; при этом все её внутренние переменные для внешних скриптов скрыты. Собственные, а также доступные родительские переменные и параметры называются окружением.</p>

      <p>Замыкание используется для ограничения области видимости и создания частных переменных, которые не могут изменить другие скрипты на странице.</p>

      <p>Замыкания часто используются для сохранения состояния в обработчиках событий.</p>

      <h4 id="section-10">Самовызывающиеся функции и выражения</h4>

      <p>Замыканием может стать любая вложенная функция. Но когда замыкание создают специально, обычно в качестве родителя используют самовызывающиеся функциональное выражение или анонимную функцию. Родительские переменные и параметры передаются вложенным функциям, и в дальнейшим не возвращаются к исходным значениям до окончания сессии.</p>

      <p>После самовызова родительской функции код оперируют только значениями, возвращаемыми вложенными функциями.</p>

      <p>Самовызывающееся выражение или функция, как следует, из названия срабатывают без вызова, сразу после своего объявления. Используется, когда нужно выполнить код один раз и сохранить его результаты для вложенных функций, без объявления глобальных переменных). Записывается с помощью двух пар круглых скобок и точки с запятой.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Анонимная самовызывающаяся функция IIFE
(Immediately-invoked Function Expression) */</span>
<span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// код функции</span>
<span class="p">})();</span>

<span class="cm">/**
 * Самовызывающееся функциональное выражение.
 * Создает замыкание для вложенной функции.
 * Переменной add присваивается результат
 * самовызывающейся функции, а это — вложенная
 * функция increment().
 */</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="cm">/* Переменная counter, созданная в add, передает
  значение вложенной функции increment() только
  раз. Далее в коде уже используются результаты
  increment(). В примере counter будет
  равняться 0 ровно до момента, когда
  increment() не увеличит его до единицы. */</span>
<span class="err">  </span><span class="kd">let</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="err">  </span><span class="cm">/**
   * Вложенная функция.
   * @return {Number}
   */</span>
<span class="err">  </span><span class="kd">function</span> <span class="nx">increment</span><span class="p">()</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">counter</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">increment</span><span class="p">;</span>
<span class="p">})();</span>

<span class="nx">add</span><span class="p">();</span> <span class="c1">// Выражение вернет 1</span>
<span class="nx">add</span><span class="p">();</span> <span class="c1">// Выражение вернет 2</span>
<span class="nx">add</span><span class="p">();</span> <span class="c1">// Выражение вернет 3</span>
</code></pre></div>      </div>

      <h3 id="iife--">IIFE с параметрами</h3>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// В первой строке мы определяем два параметра</span>
<span class="p">((</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">times</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// В цикл передаем аргументы…</span>
<span class="err">  </span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">times</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>
<span class="cm">/* …которые получаем при вызове функции в последней
строке */</span>
<span class="p">}(</span><span class="dl">"</span><span class="s2">Hello!</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>

<span class="c1">// Пример из jQuery</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="nb">global</span><span class="p">,</span> <span class="nb">document</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// use $ for jQuery, global for window</span>
<span class="p">}(</span><span class="nx">jQuery</span><span class="p">,</span> <span class="nb">window</span><span class="p">,</span> <span class="nb">document</span><span class="p">));</span>
</code></pre></div>      </div>

      <h4 id="section-11">Локальная область видимости</h4>

      <p>С каждой функцией связывается окружение, которое содержит локальные переменные из внешней области видимости (функции-родителя). Вызывая функцию на другом уровне, мы получаем и связанные с ней локальные переменные.</p>

      <p>На книжном языке это явление еще объясняют так. Каждая функция определяют свою лексическую область действия, объект переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window. Таким образом программа создает несколько объектов с независимыми свойствами и методами.</p>
    </div>
</details>
<details class="accordion" id="topic-functions-recursion">
  <summary class="accordion__header">
    <h3>Рекурсивные функции</h3>
  </summary>
  <div class="accordion__body">
      <p>В теле функции могут быть вызваны другие функции для выполнения подзадач. Но также функция может вызвать сама себя. Это называется рекурсией.</p>

      <p>Любая рекурсивная функция может быть заменена циклом.</p>

      <h4 id="section-12">Пример №1</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">countSheep</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">number</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Zzzzzz</span><span class="dl">'</span><span class="p">);</span>
<span class="err">  </span><span class="c1">// Пока количество овец не равно 0…</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">    </span><span class="c1">// …Комментировать прыжок очередной овцы.</span>
<span class="err">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">A sheep jumps over the fence.</span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="c1">// Рекурсивный вызов функции. Аргумент number</span>
<span class="err">    </span><span class="c1">// уменьшается на единицу</span>
<span class="err">    </span><span class="nx">countSheep</span><span class="p">(</span><span class="nx">number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">countSheep</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>Хотя в большинстве случаев цикл проще, понятнее рекурсии и не создает проблем со стеком (выделенным ресурсом оперативной памяти), используют то, что более удобно. Если реализация очевидна в терминах цикла, не следует использовать рекурсию. И наоборот.</p>

      <p>Так, в цикле разумнее решать задачи, где результат следующего полностью зависит от результата предыдущего.</p>

      <p><strong>При таких задачах, как обход вложенных каталогов</strong>, когда у каждого имеется ряд своих отдельных переменных (например, количество файлов в данном каталоге), <strong>легче поддерживать рекурсию</strong>. Потому что обход одного каталога совсем не зависит от результатов обхода другого соседнего каталога, и они могут <strong>работать параллельно</strong>, независимо друг от друга. А затем в конце просто объединяют все свои результаты.</p>

      <p><strong>Скорость вычислений и потребление ресурсов.</strong> На малых числах циклы и рекурсии почти не отличаются. На больших — рекурсия быстрее, но при этом использует больше оперативной памяти и ресурсов ЦП (центрального процессора; CPU).</p>

      <p>Промежуточные результаты вычисления рекурсивных функций часто сохраняются не в переменных, а в стеке (см. термины)</p>

      <h4 id="section-13">Пример №2. возведение в степень</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="c1">// Пока n не равно 1…</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="cm">/* …Функция вызывает сама себя, возвращает
    промежуточные результаты, всякий раз
    уменьшая аргумент степени на единицу
    return 2 * pow(2, 2)
    return 2 * pow(2, 1) */</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 2^3 = 8</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</code></pre></div>      </div>

      <h4 id="section-14">Пример №3</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">howManyDollars</span><span class="p">(</span><span class="nx">amountOfMoney</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="cm">/* Как правило, рекурсивная функция требует
    условия прекращения — во избежание
    бесконечных циклов */</span>
<span class="err">    </span><span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
<span class="err">      </span><span class="dl">'</span><span class="s1">The negative numbers are not allowed</span><span class="dl">'</span>
<span class="err">    </span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>

<span class="err">  </span><span class="cm">/* Т.н. базовый случай. Обычно — в конструкции
  if(). Условие окончания вычислений, выхода
  из функции, возвращение перехода к дальнейшим
  инструкциям в порядке исполнения. */</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">amountOfMoney</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>


<span class="err">  </span><span class="cm">/* Теперь функция вызывает сама себя —
  рекурсивный случай. И будет вызывать до тех
  пор, пока не достигнет условия базового
  случая — в рекурсивном случае должны быть
  заложены соответствующие вычисления. В данном
  примере (расчет сдачи при оплате покупки),
  если в сдаче меньше доллара, функция
  возвращает ноль — долларов покупателю
  не вернут. Если amountOfMoney больше доллара,
  функция откладывает 1 доллар «в сторону»,
  вычитает его из суммы сдачи. И снова
  запускает себя — до тех пор, пока не вычтет
  из суммы сдачи все целые доллары. */</span>
<span class="err">  </span><span class="k">return</span>
<span class="err">    </span><span class="mi">1</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">howManyDollars</span><span class="p">(</span><span class="nx">amountOfMoney</span> <span class="o">-</span> <span class="mf">1.00</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="section-15">Пример №4 — факториал</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">factorial</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>

<span class="err">  </span><span class="cm">/* Рекурсивный вызов с механизмом достижения
  базового случая - уменьшением аргумента */</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* В этом примере функция вызвана с аргументом 3.
Факториал числа n — произведение всех
натуральных чисел от 1 до n включительно. То
есть, нам нужно перемножить 3 * 2 * 1
и получить 6.

1) Первая итерация. 3 больше 1, значит
выполняется рекурсивный вызов. Умножаем
аргумент на факториал числа, меньшего на
единицу.
n = 3
n - 1 = 2
3 * factorial(2)
Но факториал двух нам тоже не известен.

2) Рекурсивный вызов — factorial(2).
2 * factorial(1)
Факториал единицы пока также не известен,
поэтому процедура повторяется.

3) Достигнут базовый случай n &lt;= 1
Мы получили первый ответ, который используем
поднимаясь по стеку, по логической лестнице
вверх.

4) Компьютер вычисляет факториал двух 2.
2 * 1 = 2

5) Затем, когда получено значение факториала
двух, компьютер возвращается к расчету
исходного задания — факториалу трех:
3 * 2 = 6 */</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div>      </div>

      <h4 id="section-16">Пример №5</h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Рекурсивные функции могут иметь сколько угодно
параметров… */</span>
<span class="kd">function</span> <span class="nx">howManyCoins</span><span class="p">(</span>
<span class="err">  </span><span class="nx">coinName</span><span class="p">,</span> <span class="nx">coinAmount</span><span class="p">,</span> <span class="nx">coinsSoFar</span>
<span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">change</span> <span class="o">&lt;</span> <span class="nx">coinAmount</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">coinsSoFar</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">coinName</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">change</span> <span class="o">-=</span> <span class="nx">coinAmount</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>

<span class="err">  </span><span class="cm">/* …Но в рекурсивном случае меняется, как
  правило, один или два. При этом
  задействованные параметры должны меняться
  так, чтобы приближать исполнение условия
  базового случая. В данном примере
  увеличивается количество монет определенного
  номинала в сдаче — до тех пор, пока сдача
  больше суммы монеток этого номинала */</span>
<span class="err">  </span><span class="k">return</span> <span class="nx">howManyCoins</span><span class="p">(</span>
<span class="err">    </span><span class="nx">coinName</span><span class="p">,</span> <span class="nx">coinAmount</span><span class="p">,</span> <span class="nx">coinsSoFar</span> <span class="o">+</span> <span class="mi">1</span>
<span class="err">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">howManyCoins</span><span class="p">(</span><span class="dl">'</span><span class="s1">dollar bills</span><span class="dl">'</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">howManyCoins</span><span class="p">(</span><span class="dl">'</span><span class="s1">quarters</span><span class="dl">'</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">howManyCoins</span><span class="p">(</span><span class="dl">'</span><span class="s1">dimes</span><span class="dl">'</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

</code></pre></div>      </div>
    </div>
</details>
</section>

<section>
  <h2>Объекты</h2><details class="accordion" id="topic-objects-getters-setters">
  <summary class="accordion__header">
    <h3>Аксессоры: «геттеры» и «сеттеры»</h3>
  </summary>
  <div class="accordion__body">
      <p>Для контролируемого доступа к свойствам объекта используют специальные функции, так называемые «геттеры» (оператор <code class="language-plaintext highlighter-rouge">get</code>) и «сеттеры» (<code class="language-plaintext highlighter-rouge">set</code>).</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
<span class="err">  </span><span class="na">firstName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="na">lastName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Doe</span><span class="dl">'</span><span class="p">,</span>
<span class="err">  </span><span class="na">language</span><span class="p">:</span> <span class="dl">'</span><span class="s1">en</span><span class="dl">'</span><span class="p">,</span>

<span class="err">  </span><span class="c1">// Сеттер</span>
<span class="err">  </span><span class="kd">set</span> <span class="nx">name</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">);</span>
<span class="err">    </span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">split</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="err">    </span><span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">=</span> <span class="nx">split</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="err">  </span><span class="p">},</span>

<span class="err">  </span><span class="c1">// Геттер</span>
<span class="err">  </span><span class="kd">get</span> <span class="nx">fullName</span><span class="p">()</span> <span class="p">{</span>
<span class="err">    </span><span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="err">  </span><span class="p">},</span>

<span class="err">  </span><span class="cm">/* В принципе, геттер можно заменить вот таким
  методом. Но так никто не делает — дурной тон */</span>
<span class="err">  </span><span class="na">fullNameOnceAgain</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span>
<span class="err">    </span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">}</span><span class="s2">`</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <h4 id="section-17">Сеттер</h4>

      <p>Оператор <code class="language-plaintext highlighter-rouge">set</code> содержит функцию, которая вызывается при обращении к определенному свойству объекта. Обычно эта функция создает новое свойство на основе полученного аргумента (<code class="language-plaintext highlighter-rouge">set</code> должен иметь ровно один параметр).</p>

      <p>В примере сеттер принимает строку, разделяет ее по пробелу и сохраняет первый фрагмент <code class="language-plaintext highlighter-rouge">firstName</code>, а второй — в <code class="language-plaintext highlighter-rouge">lastName</code>.</p>

      <p>Сеттеры используются чаще всего в сочетании с геттерами.</p>

      <h4 id="section-18">Геттер</h4>

      <p>Оператор <code class="language-plaintext highlighter-rouge">get</code> также содержит функцию, которая вызывается при обращении к определенному свойству объекта. С помощью «геттера» можно проверять текущее значение свойства, к которому он привязан или создавать это свойство.</p>

      <p>В примере геттер возвращает псевдо-свойство fullName.</p>

      <p>⚠️ Геттер не может иметь параметров.</p>

      <p><strong>Изменение свойств</strong> <code class="language-plaintext highlighter-rouge">firstName</code> и <code class="language-plaintext highlighter-rouge">lastName</code> с помощью сеттера <code class="language-plaintext highlighter-rouge">name</code></p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Владимир Никишин</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div>      </div>

      <p><strong>Доступ</strong> к полному имени с помощью геттера.</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">fullName</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">fullName</span><span class="p">);</span>
</code></pre></div>      </div>

      <p><strong>Доступ</strong> к полному имени с помощью метода fullNameOnceAgain — со скобками</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">fullNameOnceAgain</span><span class="p">());</span>
</code></pre></div>      </div>

      <h4 id="objectdefineproperty">Добавление геттеров и сеттеров в существующий объект — <code class="language-plaintext highlighter-rouge">Object.defineProperty()</code></h4>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">counter</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">reset</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">},</span>
<span class="p">});</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">increment</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">},</span>
<span class="p">});</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">decrement</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">},</span>
<span class="p">});</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">add</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">set</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">+=</span> <span class="nx">value</span><span class="p">;</span> <span class="p">},</span>
<span class="p">});</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">subtract</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">set</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">-=</span> <span class="nx">value</span><span class="p">;</span> <span class="p">},</span>
<span class="p">});</span>
</code></pre></div>      </div>

      <p>Вызовы геттеров и сеттеров объекта изменяют показания счетчика</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myObj</span><span class="p">.</span><span class="nx">reset</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">subtract</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">increment</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">decrement</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myObj</span><span class="p">.</span><span class="nx">counter</span><span class="p">);</span>
</code></pre></div>      </div>
    </div>
</details>
</section>

<section>
  <h2>Классы</h2><details class="accordion" id="topic-classes-deprecated-constructor-function">
  <summary class="accordion__header">
    <h3>Первоклассные функции (или функции первого класса)</h3>
  </summary>
  <div class="accordion__body">
      <p>Раньше в качестве шаблонов пользовательских объектов использовались функции, которые назывались «конструкторами».</p>

      <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Конструктор объекта</span>
<span class="kd">function</span> <span class="nx">MyConstructor</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">arg1</span><span class="p">;</span>
<span class="err">  </span><span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">=</span> <span class="nx">arg2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Создаем новый экземпляр объекта</span>
<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyConstructor</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Doe</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/* Внутри console.log — вызов функции, как метода
экземпляра объекта, созданного с помощью
конструктора. */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">firstName</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>В современных реализациях языка шаблонами пользовательских объектов служат <a href="/#topic-js-classes">классы</a>. И в них используется метод <code class="language-plaintext highlighter-rouge">constructor</code> — определяющий свойства объекта. Методы определяются за скобками <code class="language-plaintext highlighter-rouge">constructor'а</code>.</p>
    </div>
</details>
</section>

<section>
  <h2>Советы и ссылки</h2><details class="accordion" id="topic-performance-tips">
  <summary class="accordion__header">
    <h3>14 советов по оптимизации</h3>
  </summary>
  <div class="accordion__body">
      <h1 id="section-19">14 советов по оптимизации</h1>

      <p><a href="https://webformyself.com/14-sovetov-po-optimizacii-koda-javascript-dlya-front-end-razrabotchikov/">Источник</a></p>

      <h4 id="section-20">1. Удалить неиспользуемый код и функции</h4>

      <p>Чем больше кода содержится в приложении, тем больше данных необходимо передать клиенту, а браузеру потребуется больше времени для анализа и интерпретации кода.</p>

      <p>Не надо включать в сборку неиспользуемые функции — пусть они хранятся в папках исходниках.</p>

      <p>Неиспользуемый код можно удалить вручную, a также при сборке с UglifyJS или <a href="https://developers.google.com/closure/compiler/docs/api-tutorial3">Google Closure Compiler</a>.</p>

      <p>При сборке webpack’ом применяют  <a href="https://bluepnume.medium.com/javascript-tree-shaking-like-a-pro-7bf96e139eb7">технику «встряхивания дерева»</a>.</p>

      <p>Неиспользуемые пакеты npm, можно удалить командой <code class="language-plaintext highlighter-rouge">npm prune</code>.</p>

      <h4 id="section-21">2. Кешировать</h4>

      <p>Использовать <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a> или <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Caching">HTTP-кэширования</a>.</p>

      <h4 id="section-22">3. Избегайте утечек памяти</h4>

      <p>Будучи языком высокого уровня, JS заботится о нескольких низкоуровневых системах управления, таких как управление памятью. Сборка мусора — это процесс, общий для большинства языков программирования. Сборка мусора с точки зрения непрофессионала — это просто сбор и освобождение памяти, которая была выделена объектам, но которая в настоящее время не используется. В таких языках программирования, как C, разработчик должен позаботиться о распределении и освобождении памяти, используя функции <code class="language-plaintext highlighter-rouge">malloc()</code> и <code class="language-plaintext highlighter-rouge">dealloc()</code>.</p>

      <p>Даже если сборка мусора выполняется в JavaScript автоматически, могут быть определенные случаи, когда она не будет идеальной. В JavaScript ES6 <code class="language-plaintext highlighter-rouge">Map</code> и <code class="language-plaintext highlighter-rouge">Set</code> были представлены со своими «более слабыми» братьями и сестрами. Этот «более слабый» аналог, известный как <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a> и WeakSet, содержит «слабые» ссылки на объекты. Они позволяют собирать ненужные значения и предотвращать утечки памяти.</p>

      <h4 id="section-23">4. Попытайтесь выходить из циклов раньше</h4>

      <p>Обработка больших циклов может занять много времени. Поэтому следует выходить из них как можно раньше — с помощью ключевого слова <code class="language-plaintext highlighter-rouge">break</code> и ключевого слова <code class="language-plaintext highlighter-rouge">continue</code>.</p>

      <p>В приведенном ниже примере, если вы не вышли из цикла, ваш код будет запускать цикл 1000000000 раз, что явно слишком.</p>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="dl">'</span><span class="s1">----</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">970</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">found</span><span class="dl">'</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">found</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Found</span><span class="dl">"</span><span class="p">);</span>
<span class="err">    </span><span class="k">break</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>В приведенном ниже примере, если вы не сделали continue, когда цикл не соответствует условию, вы все равно будете запускать функцию 1000000000 раз. Мы обрабатываем элемент массива только в том случае, если он находится в четном положении. Это уменьшает выполнение цикла почти вдвое.</p>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="dl">'</span><span class="s1">----</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">970</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">found</span><span class="dl">'</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span><span class="p">(</span><span class="nx">i</span><span class="o">%</span><span class="mi">2</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
<span class="err">  </span><span class="k">continue</span><span class="p">;</span>
 <span class="p">};</span>
 <span class="nx">process</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <h4 id="section-24">5. Минимизируйте количество вычислений переменных</h4>

      <p>Чтобы уменьшить количество вычислений переменной, вы можете использовать замыкания. С точки зрения непрофессионала, замыкания в JavaScript предоставляют доступ к области видимости внешней функции из внутренней функции. Замыкания создаются каждый раз, когда вызывается функция created-not. Внутренние функции будут иметь доступ к переменным внешней области видимости, даже после возврата внешней функции.</p>

      <p>Давайте рассмотрим два примера, чтобы увидеть это в действии. Эти примеры взяты из блога Брета.</p>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">findCustomerCity</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">texasCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Ludwig</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Kate</span><span class="dl">'</span><span class="p">];</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">californiaCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Wade</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Lucie</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">Kylie</span><span class="dl">'</span><span class="p">];</span>

<span class="err">  </span><span class="k">return</span> <span class="nx">texasCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Texas</span><span class="dl">'</span> <span class="p">:</span>
<span class="err">    </span><span class="nx">californiaCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">California</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Unknown</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>      </div>

      <p>Если мы вызываем вышеупомянутые функции несколько раз, каждый раз создается новый объект. Для каждого вызова память излишне перераспределяется на переменные texasCustometrs и californiaCustomers. Используя решение с замыканиями, мы можем создать экземпляр переменных только один раз. Давайте рассмотрим приведенный ниже пример.</p>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">findCustomerCity</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">texasCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Ludwig</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Kate</span><span class="dl">'</span><span class="p">];</span>
<span class="err">  </span><span class="kd">const</span> <span class="nx">californiaCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Wade</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Lucie</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">Kylie</span><span class="dl">'</span><span class="p">];</span>

<span class="err">  </span><span class="k">return</span> <span class="nx">name</span> <span class="o">=&gt;</span> <span class="nx">texasCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Texas</span><span class="dl">'</span> <span class="p">:</span>
 <span class="nx">californiaCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">California</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Unknown</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">cityOfCustomer</span> <span class="o">=</span> <span class="nx">findCustomerCity</span><span class="p">();</span>
<span class="nx">cityOfCustomer</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">);</span><span class="c1">//Texas</span>
<span class="nx">cityOfCustomer</span><span class="p">(</span><span class="dl">'</span><span class="s1">Wade</span><span class="dl">'</span><span class="p">);</span><span class="c1">//California</span>
<span class="nx">cityOfCustomer</span><span class="p">(</span><span class="dl">'</span><span class="s1">Max</span><span class="dl">'</span><span class="p">);</span><span class="c1">//Unknown</span>
</code></pre></div>      </div>

      <p>В приведенном выше примере с помощью замыканий внутренняя функция, которая возвращается в переменную cityOfCustomer, имеет доступ к константам внешней функции findCustomerCity(). И всякий раз, когда вызывается внутренняя функция с именем, переданным в качестве параметра, ей не нужно снова создавать экземпляры констант.</p>

      <h4 id="dom">6. Минимизируйте доступ к DOM</h4>

      <p>Доступ к DOM медленный по сравнению с другими операторами JavaScript. Если вы внесете изменения в DOM, которые приведут к перерисовке макета, это может привести к замедлению работы.</p>

      <p>Чтобы уменьшить количество раз, когда вы обращаетесь к элементу DOM, обращайтесь к нему один раз и используйте его как локальную переменную. Когда необходимость отпадет, обязательно удалите значение переменной, установив для него null. Это предотвратит утечку памяти, поскольку позволит работать процессу сбора мусора.</p>

      <h4 id="section-25">7. Сожмите файлы</h4>

      <p>Используя такие методы сжатия, как Gzip, вы можете уменьшить размер файлов JavaScript. Эти файлы поменьше приведут к увеличению производительности сайта, так как браузер должен будет загружать меньшие ресурсы. Эти сжатия могут уменьшить размер файла до 80%. Подробнее о сжатии читайте здесь.</p>

      <h4 id="section-26">8. Оптимизируйте собранный код</h4>

      <p>Некоторые люди считают, что минимизация и сжатие – это одно и то же. Вовсе нет – это разные вещи. В сжатии используются специальные алгоритмы для изменения выходного размера файла. При минимизации в JS удаляются комментарии и лишние пробелы, переменные и функции переименовываются: длинные имена заменяются однобуквенными.</p>

      <h4 id="throttling--debouncing">9. Используйте <code class="language-plaintext highlighter-rouge">throttling</code> и <code class="language-plaintext highlighter-rouge">debouncing</code></h4>

      <p>Используя эти два метода, мы можем строго следить за тем, сколько раз событие должно обрабатываться кодом.
При <code class="language-plaintext highlighter-rouge">throttling</code> указывается максимальное количество раз, когда функция может быть вызвана. Например, «выполнять функцию события <code class="language-plaintext highlighter-rouge">onkeyup</code> не чаще, чем раз в 1000 миллисекунд». Это будет означать, что если вы нажмете клавиши 20 раз в секунду, событие будет срабатывать только один раз в секунду. Это уменьшит нагрузку на код.</p>

      <p><a href="../07-dom/window/02-window-ready-load-resize.md">С другой стороны, <code class="language-plaintext highlighter-rouge">debouncing</code></a> — это то, где вы указываете минимальную продолжительность времени для повторного запуска функции с момента предыдущего выполнения той же функции. Другими словами, «выполняйте эту функцию, только если прошло 600 миллисекунд без ее вызова».</p>

      <p>Вы можете реализовать собственные функции <code class="language-plaintext highlighter-rouge">debounce</code> и <code class="language-plaintext highlighter-rouge">throttle</code>. Последний, используется чаще, так как является более универсальным.</p>

      <p>Также можно импортировать готовые функции из библиотеки Lodash (<a href="https://www.sitepoint.com/throttle-scroll-events/">предпочтительный метод</a>). <code class="language-plaintext highlighter-rouge">Импортировать можно при сборке Webpack'ом</code>(https://stackoverflow.com/questions/35250500/correct-way-to-import-lodash), который включает loadash.</p>

      <h4 id="delete">10. Избегайте использования ключевого слова delete</h4>

      <p>Ключевое слово delete используется, чтобы удалить свойство из объекта. В качестве альтернативы, вы можете просто установить нежелательное свойство как <code class="language-plaintext highlighter-rouge">undefined</code>.</p>

      <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="mi">43</span><span class="p">};</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div>      </div>

      <p>Вы также можете использовать объект Map, так как его метод <code class="language-plaintext highlighter-rouge">delete</code> работает быстрее.</p>

      <h4 id="section-27">11. Используйте асинхронный код для предотвращения блокировки потоков</h4>

      <p>Вы должны знать, что JavaScript является синхронным по умолчанию, а также однопоточным. Но могут быть случаи, когда коду требуется много времени для вычислений. Будучи синхронным по своей природе, для JavaScript это будет означать, что этот фрагмент кода будет блокировать выполнение других операторов кода до тех пор, пока он не будет выполнен. Это снизит производительность в целом.</p>

      <p>Но мы можем предотвратить эту ситуацию, внедрив асинхронный код. Асинхронный код был ранее написан в форме обратных вызовов, но с ES6 был введен новый стиль обработки асинхронного кода. Этот новый стиль был назван <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Using_promises">промисами</a>.</p>

      <h4 id="section-28">12.  Используйте разделение кода</h4>

      <p>Если у вас есть опыт работы с Google Lighthouse, вы знакомы с метрикой, которая называется «первое значимое отображение». Это один из шести показателей, отслеживаемых в разделе «Производительность» отчета Light House.
First Contentful Paint (FCP) измеряет, сколько времени браузеру требуется для отображения первого фрагмента содержимого DOM после перехода пользователя на вашу страницу. Изображения, небелые <canvas> элементы и SVG на странице считаются содержимым DOM; ничего внутри iframe не включено.</canvas></p>

      <p>Один из лучших способов получить более высокий балл FCP — использовать разделение кода. Разделение кода — это метод, при котором вы сначала отправляете пользователю только необходимые модули. Это сильно повлияет на оценку FCP, уменьшая размер полезной нагрузки, передаваемой изначально.</p>

      <p>Популярные пакеты модулей, такие как webpack, предоставляют функционал разделения кода. Вы также можете использовать собственные модули ES, чтобы загрузить отдельные модули.</p>

      <h4 id="async--defer">13. Используйте <code class="language-plaintext highlighter-rouge">async</code> и <code class="language-plaintext highlighter-rouge">defer</code></h4>

      <h4 id="web-worker--------">14.  Используйте Web Worker для выполнения интенсивных задач процессора в фоновом режиме</h4>

      <p><a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a> позволяют запускать скрипты в фоновых потоках. Если у вас есть очень интенсивные задачи, вы можете назначить их для Web Worker, которые будут выполнять их без вмешательства в пользовательский интерфейс. После создания Web Worker может общаться с кодом JavaScript, отправляя сообщения в обработчик событий, указанный этим кодом. Это может происходить и наоборот.</p>

    </div>
</details>
<details class="accordion">
  <summary class="accordion__header">
    <h3>Полезные ссылки</h3>
  </summary>
  <div class="accordion__body">
      <ul>
        <li><a href="https://learn.javascript.ru/web-components">Веб-компоненты</a></li>
        <li><strong>Символ</strong> — уникальный и неизменяемый примитивный тип данных, который может быть использован как ключ для свойств объектов. См. в <a href="https://www.w3schools.com/js/js_es6.asp#mark_symbol" target="_blank">W3Schools</a> и «<a href="https://learn.javascript.ru/symbol" target="_blank">современном учебнике</a>».</li>
        <li><a href="https://doka.guide/js/shallow-or-deep-clone/" target="_blank">Поверхностное и глубокое копирование</a></li>
        <li><a href="https://www.stevenchang.tw/blog/2020/05/23/JavaScript-slice-call-function" target="_blank"><code class="language-plaintext highlighter-rouge">Array.prototype.slice</code> \ <code class="language-plaintext highlighter-rouge">\[\].slice.call()</code> — прием для применения методов массива к <code class="language-plaintext highlighter-rouge">NodeList</code></a></li>
        <li><a href="https://developer.mozilla.org/ru/docs/Web/API" target="_blank">Интерфейсы веб API</a>:
          <ul>
            <li>Blob — <a href="https://developer.mozilla.org/ru/docs/Web/API/Blob" target="_blank">1</a>, <a href="https://learn.javascript.ru/blob" target="_blank">2</a>, <a href="https://docs.microsoft.com/en-us/answers/questions/480791/what-is-the-difference-between-storing-documents-i.html#answer-481051" target="_blank">3</a></li>
            <li><a href="https://www.w3schools.com/html/html5_geolocation.asp" target="_blank">Гео</a></li>
            <li><a href="https://www.w3schools.com/html/html5_draganddrop.asp" target="_blank">Drag and drop</a></li>
            <li><a href="https://www.w3schools.com/html/html5_webstorage.asp" target="_blank">Веб хранилище</a></li>
            <li><a href="https://www.w3schools.com/html/html5_webworkers.asp" target="_blank">Web Workers</a></li>
            <li><a href="https://www.w3schools.com/html/html5_serversentevents.asp" target="_blank">Server-sent events</a></li>
          </ul>
        </li>
        <li><a href="https://developer.mozilla.org/ru/docs/WebAssembly/Concepts">WebAssembly</a> - это технология, предоставляющая новый тип кода, который можно запускать в современных веб-браузерах. Код для WebAssembly не пишется вручную, а компилируется из низкоуровневых исходных языков C, C++, Rust и.т.д.</li>
      </ul>

      <h4 id="section-29">Справочники</h4>

      <ul>
        <li><a href="https://thisthat.dev/" target="_blank">What is the difference</a></li>
        <li><a href="https://1loc.dev/" target="_blank">Favorite JavaScript Utilities</a></li>
        <li><a href="https://www.canidev.tools/" target="_blank">CanIuse DevTools</a> - раздел JS; надо клинкуть на чекбокс, чтобы открыть инструкции.</li>
      </ul>
    </div>
</details>
</section>

<p>См. также <a href="/">шпаргалку</a> и <a href="/js/how-to.html">практическое руководство</a>.</p>

</main><footer class="footer">
  <p class="footer__copyright">
    © 2022 Владимир Никишин,&nbsp;
    <a href="https://super-mark.ru/" target="_blank" rel="noopener noreferrer">
      SuperMark
    </a>.
  </p>
  <p class="footer__credits-caption">По материалам:</p>
  <ul class="footer__credits"><li><a href="https://htmldom.dev/" target="_blank" rel="noopener noreferrer">HTML DOM</a>.</li></ul>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
<script src="/assets/js/main.js?20220805-1313"></script>

<script>
  hljs.highlightAll();
</script>

  </body>
</html>
