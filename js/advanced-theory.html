<!DOCTYPE html>
<html lang="ru" prefix="og: http://ogp.me/ns#"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>JavaScript. Теория — углубленное изучение</title>
<meta name="description" content="{%- include details.html title=&quot;14 советов по оптимизации&quot; path=&quot;_advanced/best-practicies-perfomance.md&quot; id=&quot;topic-performance-tips&quot; -%}
{%- include details.html title=&quot;Полезные ссылки&quot; path=&quot;_advanced/links.md&quot; -%}

См. также [шпаргалку](/) и [практическое руководство](/js/how-to.html).
">
<meta name="author" content="Vladimir Nikishin, www.super-mark.ru">
<meta name="apple-mobile-web-app-title" content="Шпоры">
<meta name="theme-color" content="#e5effa"><link rel="canonical" href="https://cheatsheets.super-mark.ru/js/advanced-theory"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Roboto:wght@400;500&display=swap">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs-themes@1.0.0/mono-blue.css">
<link rel="stylesheet" href="/assets/css/style.css?20220725-1213">
</head>
<body>
    <main class="main">
  <h1>JavaScript. Теория — углубленное изучение</h1>
  <input class="input__field is-lg" id="topic-filter" type="text" placeholder="Фильтр записей: введите запрос">

  <details class="accordion" id="topic-performance-tips">
  <summary class="accordion__header">
    <h3>14 советов по оптимизации</h3>
  </summary>
  <div class="accordion__body">
    <h1 id="section">14 советов по оптимизации</h1>

    <p><a href="https://webformyself.com/14-sovetov-po-optimizacii-koda-javascript-dlya-front-end-razrabotchikov/">Источник</a></p>

    <h2 id="section-1">1. Удалить неиспользуемый код и функции</h2>

    <p>Чем больше кода содержится в приложении, тем больше данных необходимо передать клиенту, а браузеру потребуется больше времени для анализа и интерпретации кода.</p>

    <p>Не надо включать в сборку неиспользуемые функции — пусть они хранятся в папках исходниках.</p>

    <p>Неиспользуемый код можно удалить вручную, a также при сборке с UglifyJS или <a href="https://developers.google.com/closure/compiler/docs/api-tutorial3">Google Closure Compiler</a>.</p>

    <p>При сборке webpack’ом применяют  <a href="https://bluepnume.medium.com/javascript-tree-shaking-like-a-pro-7bf96e139eb7">технику «встряхивания дерева»</a>.</p>

    <p>Неиспользуемые пакеты npm, можно удалить командой <code class="language-plaintext highlighter-rouge">npm prune</code>.</p>

    <h2 id="section-2">2. Кешировать</h2>

    <p>Использовать <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a> или <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Caching">HTTP-кэширования</a>.</p>

    <h2 id="section-3">3. Избегайте утечек памяти</h2>

    <p>Будучи языком высокого уровня, JS заботится о нескольких низкоуровневых системах управления, таких как управление памятью. Сборка мусора — это процесс, общий для большинства языков программирования. Сборка мусора с точки зрения непрофессионала — это просто сбор и освобождение памяти, которая была выделена объектам, но которая в настоящее время не используется. В таких языках программирования, как C, разработчик должен позаботиться о распределении и освобождении памяти, используя функции <code class="language-plaintext highlighter-rouge">malloc()</code> и <code class="language-plaintext highlighter-rouge">dealloc()</code>.</p>

    <p>Даже если сборка мусора выполняется в JavaScript автоматически, могут быть определенные случаи, когда она не будет идеальной. В JavaScript ES6 <code class="language-plaintext highlighter-rouge">Map</code> и <code class="language-plaintext highlighter-rouge">Set</code> были представлены со своими «более слабыми» братьями и сестрами. Этот «более слабый» аналог, известный как <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a> и WeakSet, содержит «слабые» ссылки на объекты. Они позволяют собирать ненужные значения и предотвращать утечки памяти.</p>

    <h2 id="section-4">4. Попытайтесь выходить из циклов раньше</h2>

    <p>Обработка больших циклов может занять много времени. Поэтому следует выходить из них как можно раньше — с помощью ключевого слова <code class="language-plaintext highlighter-rouge">break</code> и ключевого слова <code class="language-plaintext highlighter-rouge">continue</code>.</p>

    <p>В приведенном ниже примере, если вы не вышли из цикла, ваш код будет запускать цикл 1000000000 раз, что явно слишком.</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="dl">'</span><span class="s1">----</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">970</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">found</span><span class="dl">'</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">found</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Found</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>В приведенном ниже примере, если вы не сделали continue, когда цикл не соответствует условию, вы все равно будете запускать функцию 1000000000 раз. Мы обрабатываем элемент массива только в том случае, если он находится в четном положении. Это уменьшает выполнение цикла почти вдвое.</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="dl">'</span><span class="s1">----</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">970</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">found</span><span class="dl">'</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">i</span><span class="o">%</span><span class="mi">2</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
  <span class="k">continue</span><span class="p">;</span>
 <span class="p">};</span>
 <span class="nx">process</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <h2 id="section-5">5. Минимизируйте количество вычислений переменных</h2>

    <p>Чтобы уменьшить количество вычислений переменной, вы можете использовать замыкания. С точки зрения непрофессионала, замыкания в JavaScript предоставляют доступ к области видимости внешней функции из внутренней функции. Замыкания создаются каждый раз, когда вызывается функция created-not. Внутренние функции будут иметь доступ к переменным внешней области видимости, даже после возврата внешней функции.</p>

    <p>Давайте рассмотрим два примера, чтобы увидеть это в действии. Эти примеры взяты из блога Брета.</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">findCustomerCity</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">texasCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Ludwig</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Kate</span><span class="dl">'</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">californiaCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Wade</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Lucie</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">Kylie</span><span class="dl">'</span><span class="p">];</span>

  <span class="k">return</span> <span class="nx">texasCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Texas</span><span class="dl">'</span> <span class="p">:</span>
    <span class="nx">californiaCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">California</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Unknown</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>    </div>

    <p>Если мы вызываем вышеупомянутые функции несколько раз, каждый раз создается новый объект. Для каждого вызова память излишне перераспределяется на переменные texasCustometrs и californiaCustomers. Используя решение с замыканиями, мы можем создать экземпляр переменных только один раз. Давайте рассмотрим приведенный ниже пример.</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">findCustomerCity</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">texasCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Ludwig</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Kate</span><span class="dl">'</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">californiaCustomers</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Wade</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Lucie</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">Kylie</span><span class="dl">'</span><span class="p">];</span>

  <span class="k">return</span> <span class="nx">name</span> <span class="o">=&gt;</span> <span class="nx">texasCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Texas</span><span class="dl">'</span> <span class="p">:</span>
 <span class="nx">californiaCustomers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">California</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Unknown</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">cityOfCustomer</span> <span class="o">=</span> <span class="nx">findCustomerCity</span><span class="p">();</span>
<span class="nx">cityOfCustomer</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">);</span><span class="c1">//Texas</span>
<span class="nx">cityOfCustomer</span><span class="p">(</span><span class="dl">'</span><span class="s1">Wade</span><span class="dl">'</span><span class="p">);</span><span class="c1">//California</span>
<span class="nx">cityOfCustomer</span><span class="p">(</span><span class="dl">'</span><span class="s1">Max</span><span class="dl">'</span><span class="p">);</span><span class="c1">//Unknown</span>
</code></pre></div>    </div>

    <p>В приведенном выше примере с помощью замыканий внутренняя функция, которая возвращается в переменную cityOfCustomer, имеет доступ к константам внешней функции findCustomerCity(). И всякий раз, когда вызывается внутренняя функция с именем, переданным в качестве параметра, ей не нужно снова создавать экземпляры констант.</p>

    <h2 id="dom">6. Минимизируйте доступ к DOM</h2>

    <p>Доступ к DOM медленный по сравнению с другими операторами JavaScript. Если вы внесете изменения в DOM, которые приведут к перерисовке макета, это может привести к замедлению работы.</p>

    <p>Чтобы уменьшить количество раз, когда вы обращаетесь к элементу DOM, обращайтесь к нему один раз и используйте его как локальную переменную. Когда необходимость отпадет, обязательно удалите значение переменной, установив для него null. Это предотвратит утечку памяти, поскольку позволит работать процессу сбора мусора.</p>

    <h2 id="section-6">7. Сожмите файлы</h2>

    <p>Используя такие методы сжатия, как Gzip, вы можете уменьшить размер файлов JavaScript. Эти файлы поменьше приведут к увеличению производительности сайта, так как браузер должен будет загружать меньшие ресурсы. Эти сжатия могут уменьшить размер файла до 80%. Подробнее о сжатии читайте здесь.</p>

    <h2 id="section-7">8. Оптимизируйте собранный код</h2>

    <p>Некоторые люди считают, что минимизация и сжатие – это одно и то же. Вовсе нет – это разные вещи. В сжатии используются специальные алгоритмы для изменения выходного размера файла. При минимизации в JS удаляются комментарии и лишние пробелы, переменные и функции переименовываются: длинные имена заменяются однобуквенными.</p>

    <h2 id="throttling--debouncing">9. Используйте <code class="language-plaintext highlighter-rouge">throttling</code> и <code class="language-plaintext highlighter-rouge">debouncing</code></h2>

    <p>Используя эти два метода, мы можем строго следить за тем, сколько раз событие должно обрабатываться кодом.
При <code class="language-plaintext highlighter-rouge">throttling</code> указывается максимальное количество раз, когда функция может быть вызвана. Например, «выполнять функцию события <code class="language-plaintext highlighter-rouge">onkeyup</code> не чаще, чем раз в 1000 миллисекунд». Это будет означать, что если вы нажмете клавиши 20 раз в секунду, событие будет срабатывать только один раз в секунду. Это уменьшит нагрузку на код.</p>

    <p><a href="../07-dom/window/02-window-ready-load-resize.md">С другой стороны, <code class="language-plaintext highlighter-rouge">debouncing</code></a> — это то, где вы указываете минимальную продолжительность времени для повторного запуска функции с момента предыдущего выполнения той же функции. Другими словами, «выполняйте эту функцию, только если прошло 600 миллисекунд без ее вызова».</p>

    <p>Вы можете реализовать собственные функции <code class="language-plaintext highlighter-rouge">debounce</code> и <code class="language-plaintext highlighter-rouge">throttle</code>. Последний, используется чаще, так как является более универсальным.</p>

    <p>Также можно импортировать готовые функции из библиотеки Lodash (<a href="https://www.sitepoint.com/throttle-scroll-events/">предпочтительный метод</a>). <code class="language-plaintext highlighter-rouge">Импортировать можно при сборке Webpack'ом</code>(https://stackoverflow.com/questions/35250500/correct-way-to-import-lodash), который включает loadash.</p>

    <h2 id="delete">10. Избегайте использования ключевого слова delete</h2>

    <p>Ключевое слово delete используется, чтобы удалить свойство из объекта. В качестве альтернативы, вы можете просто установить нежелательное свойство как <code class="language-plaintext highlighter-rouge">undefined</code>.</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="mi">43</span><span class="p">};</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Вы также можете использовать объект Map, так как его метод <code class="language-plaintext highlighter-rouge">delete</code> работает быстрее.</p>

    <h2 id="section-8">11. Используйте асинхронный код для предотвращения блокировки потоков</h2>

    <p>Вы должны знать, что JavaScript является синхронным по умолчанию, а также однопоточным. Но могут быть случаи, когда коду требуется много времени для вычислений. Будучи синхронным по своей природе, для JavaScript это будет означать, что этот фрагмент кода будет блокировать выполнение других операторов кода до тех пор, пока он не будет выполнен. Это снизит производительность в целом.</p>

    <p>Но мы можем предотвратить эту ситуацию, внедрив асинхронный код. Асинхронный код был ранее написан в форме обратных вызовов, но с ES6 был введен новый стиль обработки асинхронного кода. Этот новый стиль был назван <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Using_promises">промисами</a>.</p>

    <h2 id="section-9">12.  Используйте разделение кода</h2>

    <p>Если у вас есть опыт работы с Google Lighthouse, вы знакомы с метрикой, которая называется «первое значимое отображение». Это один из шести показателей, отслеживаемых в разделе «Производительность» отчета Light House.
First Contentful Paint (FCP) измеряет, сколько времени браузеру требуется для отображения первого фрагмента содержимого DOM после перехода пользователя на вашу страницу. Изображения, небелые <canvas> элементы и SVG на странице считаются содержимым DOM; ничего внутри iframe не включено.</canvas></p>

    <p>Один из лучших способов получить более высокий балл FCP — использовать разделение кода. Разделение кода — это метод, при котором вы сначала отправляете пользователю только необходимые модули. Это сильно повлияет на оценку FCP, уменьшая размер полезной нагрузки, передаваемой изначально.</p>

    <p>Популярные пакеты модулей, такие как webpack, предоставляют функционал разделения кода. Вы также можете использовать собственные модули ES, чтобы загрузить отдельные модули.</p>

    <h2 id="async--defer">13. Используйте <a href="01-html.md"><code class="language-plaintext highlighter-rouge">async</code> и <code class="language-plaintext highlighter-rouge">defer</code></a></h2>

    <h2 id="web-worker--------">14.  Используйте Web Worker для выполнения интенсивных задач процессора в фоновом режиме</h2>

    <p><a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a> позволяют запускать скрипты в фоновых потоках. Если у вас есть очень интенсивные задачи, вы можете назначить их для Web Worker, которые будут выполнять их без вмешательства в пользовательский интерфейс. После создания Web Worker может общаться с кодом JavaScript, отправляя сообщения в обработчик событий, указанный этим кодом. Это может происходить и наоборот.</p>

  </div>
</details>
<details class="accordion">
  <summary class="accordion__header">
    <h3>Полезные ссылки</h3>
  </summary>
  <div class="accordion__body">
    <ul>
      <li><a href="https://learn.javascript.ru/web-components">Веб-компоненты</a></li>
      <li><strong>Символ</strong> — уникальный и неизменяемый примитивный тип данных, который может быть использован как ключ для свойств объектов. См. в <a href="https://www.w3schools.com/js/js_es6.asp#mark_symbol" target="_blank">W3Schools</a> и «<a href="https://learn.javascript.ru/symbol" target="_blank">современном учебнике</a>».</li>
      <li><a href="https://doka.guide/js/shallow-or-deep-clone/" target="_blank">Поверхностное и глубокое копирование</a></li>
      <li><a href="https://www.stevenchang.tw/blog/2020/05/23/JavaScript-slice-call-function" target="_blank"><code class="language-plaintext highlighter-rouge">Array.prototype.slice</code> \ <code class="language-plaintext highlighter-rouge">\[\].slice.call()</code> — прием для применения методов массива к <code class="language-plaintext highlighter-rouge">NodeList</code></a></li>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/API" target="_blank">Интерфейсы веб API</a>:
        <ul>
          <li>Blob — <a href="https://developer.mozilla.org/ru/docs/Web/API/Blob" target="_blank">1</a>, <a href="https://learn.javascript.ru/blob" target="_blank">2</a>, <a href="https://docs.microsoft.com/en-us/answers/questions/480791/what-is-the-difference-between-storing-documents-i.html#answer-481051" target="_blank">3</a></li>
          <li><a href="https://www.w3schools.com/html/html5_geolocation.asp" target="_blank">Гео</a></li>
          <li><a href="https://www.w3schools.com/html/html5_draganddrop.asp" target="_blank">Drag and drop</a></li>
          <li><a href="https://www.w3schools.com/html/html5_webstorage.asp" target="_blank">Веб хранилище</a></li>
          <li><a href="https://www.w3schools.com/html/html5_webworkers.asp" target="_blank">Web Workers</a></li>
          <li><a href="https://www.w3schools.com/html/html5_serversentevents.asp" target="_blank">Server-sent events</a></li>
        </ul>
      </li>
      <li><a href="https://developer.mozilla.org/ru/docs/WebAssembly/Concepts">WebAssembly</a> - это технология, предоставляющая новый тип кода, который можно запускать в современных веб-браузерах. Код для WebAssembly не пишется вручную, а компилируется из низкоуровневых исходных языков C, C++, Rust и.т.д.</li>
    </ul>

    <h4 id="section-10">Справочники</h4>

    <ul>
      <li><a href="https://thisthat.dev/" target="_blank">What is the difference</a></li>
      <li><a href="https://1loc.dev/" target="_blank">Favorite JavaScript Utilities</a></li>
      <li><a href="https://www.canidev.tools/" target="_blank">CanIuse DevTools</a> - раздел JS; надо клинкуть на чекбокс, чтобы открыть инструкции.</li>
    </ul>
  </div>
</details>
<p>См. также <a href="/">шпаргалку</a> и <a href="/js/how-to.html">практическое руководство</a>.</p>

</main><footer class="footer">
  <p class="footer__copyright">
    © 2022 Владимир Никишин,&nbsp;
    <a href="https://super-mark.ru/" target="_blank" rel="noopener noreferrer">
      SuperMark
    </a>.
  </p>
  <p class="footer__credits-caption">По материалам:</p>
  <ul class="footer__credits"><li><a href="https://htmldom.dev/" target="_blank" rel="noopener noreferrer">HTML DOM</a>.</li></ul>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
<script src="/assets/js/main.js?20220725-1213"></script>

<script>
  hljs.highlightAll();
</script>

  </body>
</html>
